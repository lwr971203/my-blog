<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>c++11特性 | 个人博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="lwr的个人博客">
    
    <link rel="preload" href="/my-blog/assets/css/0.styles.8e9e9e1d.css" as="style"><link rel="preload" href="/my-blog/assets/js/app.8e128a0c.js" as="script"><link rel="preload" href="/my-blog/assets/js/7.9bc745bc.js" as="script"><link rel="preload" href="/my-blog/assets/js/2.1c59524a.js" as="script"><link rel="preload" href="/my-blog/assets/js/1.4270a9d7.js" as="script"><link rel="preload" href="/my-blog/assets/js/39.73ed935c.js" as="script"><link rel="prefetch" href="/my-blog/assets/js/10.db0e7049.js"><link rel="prefetch" href="/my-blog/assets/js/11.be2e0167.js"><link rel="prefetch" href="/my-blog/assets/js/14.039cc613.js"><link rel="prefetch" href="/my-blog/assets/js/15.a38565a3.js"><link rel="prefetch" href="/my-blog/assets/js/16.c20929a1.js"><link rel="prefetch" href="/my-blog/assets/js/17.b3160632.js"><link rel="prefetch" href="/my-blog/assets/js/18.223442dc.js"><link rel="prefetch" href="/my-blog/assets/js/19.2effed27.js"><link rel="prefetch" href="/my-blog/assets/js/20.742bfb3e.js"><link rel="prefetch" href="/my-blog/assets/js/21.ba8bdb48.js"><link rel="prefetch" href="/my-blog/assets/js/22.2a260054.js"><link rel="prefetch" href="/my-blog/assets/js/23.a54cbeb5.js"><link rel="prefetch" href="/my-blog/assets/js/24.b59dbd98.js"><link rel="prefetch" href="/my-blog/assets/js/25.21b3ea40.js"><link rel="prefetch" href="/my-blog/assets/js/26.19cd6834.js"><link rel="prefetch" href="/my-blog/assets/js/27.2064fffd.js"><link rel="prefetch" href="/my-blog/assets/js/28.82406389.js"><link rel="prefetch" href="/my-blog/assets/js/29.f3831ded.js"><link rel="prefetch" href="/my-blog/assets/js/3.5cd4e6c1.js"><link rel="prefetch" href="/my-blog/assets/js/30.6a9cb3e4.js"><link rel="prefetch" href="/my-blog/assets/js/31.39857869.js"><link rel="prefetch" href="/my-blog/assets/js/32.9f9b9041.js"><link rel="prefetch" href="/my-blog/assets/js/33.6c30c999.js"><link rel="prefetch" href="/my-blog/assets/js/34.fa4aff25.js"><link rel="prefetch" href="/my-blog/assets/js/35.54780a93.js"><link rel="prefetch" href="/my-blog/assets/js/36.b81c8de2.js"><link rel="prefetch" href="/my-blog/assets/js/37.a1297d86.js"><link rel="prefetch" href="/my-blog/assets/js/38.2497ee2d.js"><link rel="prefetch" href="/my-blog/assets/js/4.4369a37a.js"><link rel="prefetch" href="/my-blog/assets/js/40.3b4e4ea3.js"><link rel="prefetch" href="/my-blog/assets/js/41.0fa78e59.js"><link rel="prefetch" href="/my-blog/assets/js/42.d058a277.js"><link rel="prefetch" href="/my-blog/assets/js/43.50b20d44.js"><link rel="prefetch" href="/my-blog/assets/js/5.199097ef.js"><link rel="prefetch" href="/my-blog/assets/js/6.122eb8c3.js"><link rel="prefetch" href="/my-blog/assets/js/8.b2e33b3e.js"><link rel="prefetch" href="/my-blog/assets/js/9.e819fb8a.js"><link rel="prefetch" href="/my-blog/assets/js/vendors~docsearch.e143dbd5.js">
    <link rel="stylesheet" href="/my-blog/assets/css/0.styles.8e9e9e1d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>个人博客</h3> <p class="description" data-v-59e6cb88>lwr的个人博客</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2024
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/my-blog/" class="home-link router-link-active"><!----> <span class="site-name">个人博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/my-blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      lwr的个人博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/lwr971203" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://www.yuque.com/lwr971203" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  语雀
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>6</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/my-blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      lwr的个人博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/lwr971203" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://www.yuque.com/lwr971203" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  语雀
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/my-blog/" class="sidebar-heading clickable router-link-active"><span>欢迎光临</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/my-blog/cpp/列表初始化" class="sidebar-heading clickable open"><span>c++</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/my-blog/cpp/列表初始化.html" class="sidebar-link">列表初始化</a></li><li><a href="/my-blog/cpp/c++11.html" aria-current="page" class="active sidebar-link">c++11</a></li><li><a href="/my-blog/cpp/c++类型转换.html" class="sidebar-link">c++类型转换</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/my-blog/qt/README.md" class="sidebar-heading clickable"><span>qt基础知识</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88></h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2024
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">c++11特性</h1> <div data-v-8a445198><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="c-11特性"><a href="#c-11特性" class="header-anchor">#</a> c++11特性</h1> <blockquote><p>本篇笔记全部由我本人手写，参考网上的文章和权威的手册，逐一论证。
在学习和验证的过程中，发现很多市面上流传的结论是错的或者不完全正确，为此特意花了大量的时间修正。</p></blockquote> <h2 id="long-long-类型"><a href="#long-long-类型" class="header-anchor">#</a> long long 类型</h2> <ul><li>long long 类型：长整形，占8字节，64位的。可表示范围：-2^63 ~ 2 ^ 63 -1。</li> <li>对于有符号的long long 类型，后缀用&quot;LL&quot;或者&quot;II&quot;标识，就比如&quot;10LL&quot;就表示有符号超长整数10。对于无符号的long long 类型，后缀用&quot;ULL&quot;或者&quot;UII&quot;标识，就比如&quot;10ULL&quot;就表示无符号超长整数10.</li> <li>long long 类型常见的三个宏：
<ul><li>LLONG_MIN:代表当前平台最小的 long long 类型整数</li> <li>LLONG_MAX:代表当前平台最大的 long long 类型整数</li> <li>ULLONG_MAX:代表当前平台上最大的 unsigned long long 类型整数（无符号超长整型的最小值为 0）</li></ul></li></ul> <h2 id="std-array"><a href="#std-array" class="header-anchor">#</a> std::array</h2> <ul><li>array 是 c++11 新增的模板类，完全可以用来替代原始的数组。
<ul><li>它的长度也是固定的，不允许新增或者删除元素</li> <li>提供了很多 array 相关的函数便于使用</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;array&gt;</span> <span class="token comment">// 需要引入这个头文件</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span> arr1 <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> arr1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> arr1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 0 不安全的值</span>
    cout <span class="token operator">&lt;&lt;</span> arr1<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 相对于使用 [] 访问更安全，它会在运行时检查索引是否越界，但效率相对而言没那么高</span>
    <span class="token comment">// cout &lt;&lt; arr1.at(-2) &lt;&lt; endl; // error</span>
    cout <span class="token operator">&lt;&lt;</span> arr1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 10</span>
    cout <span class="token operator">&lt;&lt;</span> arr1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// false</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>arr1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 1</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span>arr1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 10</span>

    <span class="token keyword">int</span><span class="token operator">*</span> arr2 <span class="token operator">=</span> arr1<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 得到底层维护的指针</span>

    array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span> arr3 <span class="token operator">=</span> arr1<span class="token punctuation">;</span> <span class="token comment">// 允许将一个 array 赋值给另一个 array , 这对于原始数组来说是不行的</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> ele <span class="token operator">:</span> arr3<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> ele <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="nullptr常量"><a href="#nullptr常量" class="header-anchor">#</a> nullptr常量</h2> <p>nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。nullptr 是这个类型的一个预定义值。可以隐式转换成各种指针类型。是是真正可以表示空指针的预定义值，而不是 NULL 这种常量0。解决了 Func(NULL) 调用的是 Func(int n) 这类不符合预期的问题</p> <h2 id="constexpr"><a href="#constexpr" class="header-anchor">#</a> constexpr</h2> <ul><li>constexpr 表示在编译期确定的常量 (是真正的常量，地位相当于字面量，等价于 c#中的 const)，const 只是单纯的表示只读（等价于 c# 中的 readonly）。从语义上看对比 c# 糟糕太多了，属于一开始考虑不周导致的。</li> <li>constexpr 的必须使用常量表达式进行初始化</li> <li>constexpr 的指针必须指向全局区。并且 constexpr 指针效果与指针常量相似</li> <li>constexpr 函数：可修饰普通函数、成员函数、函数模板。（constexpr未必生效，仅当只用到常量表达式函数的时候，才是）
<ul><li>必须有返回值，不能为 void （c++17解除了限制）</li> <li>函数体中只能出现常量表达式（除了 using、typedef、static_assert以及return语句），否则会有警告</li> <li>使用之前必须定义（c++17解除了限制）</li></ul></li> <li>constexpr 可以修饰对象，使之成为常量表达式对象。</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">;</span> <span class="token comment">// count 和 num 都是只读的局部变量</span>
    <span class="token keyword">int</span> arr1<span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// ok 原则上来说这是不合理的，但是 g++ 不知道哪个版本开始支持使用变量定义数组长度</span>
    <span class="token keyword">int</span> arr2<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token keyword">int</span> num<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">constexpr</span> Demo demo<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> id <span class="token operator">=</span> demo<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> num <span class="token operator">=</span> demo<span class="token punctuation">.</span>num<span class="token punctuation">;</span>
    <span class="token comment">// demo.num += 100; // error</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;id = &quot;</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, num = &quot;</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 返回值为 void，c++17 没有报错。 c++11 不允许</span>
<span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">Test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token comment">// cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; endl; // warning 常量表达式函数的函数体中不要使用非常量表达式的语句（using、typedef、static_assert、return除外）</span>
<span class="token punctuation">}</span>

<span class="token comment">// return 一个非常量表达式，c++17 没有报错。 c++11 不允许</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">Test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token comment">// return 一个非常量表达式 此时这个函数必定沦为非常量表达式函数</span>
<span class="token punctuation">}</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">Test5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不完整的常量表达式函数</span>

<span class="token comment">// 可能为常量表达式的函数模板。具体得看函数模板实例化的情况</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">constexpr</span> T <span class="token function">Get</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Test6</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Demo demo1<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    Demo d1 <span class="token operator">=</span> <span class="token function">Get</span><span class="token punctuation">(</span>demo1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Get 此时只是一个非常量表达式函数</span>

    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> i1 <span class="token operator">=</span> <span class="token function">Get</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Get 此时是一个常量表达式函数</span>

    <span class="token keyword">constexpr</span> Demo demo2<span class="token punctuation">{</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> Demo d2 <span class="token operator">=</span> <span class="token function">Get</span><span class="token punctuation">(</span>demo2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Get 此时是一个常量表达式函数</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token comment">// 可以使用 constexpr 标记构造函数成为常量表达式构造函数。并且要求空函数体</span>
    <span class="token keyword">constexpr</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">age</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Test7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">constexpr</span> Person person<span class="token punctuation">{</span><span class="token string">&quot;luffy&quot;</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 因为调用常量表达式构造函数创建出来的对象是常量表达式对象，所以用 constexpr 标记</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;name = &quot;</span> <span class="token operator">&lt;&lt;</span> person<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, age = &quot;</span> <span class="token operator">&lt;&lt;</span> person<span class="token punctuation">.</span>age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Test5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用不完整的常量表达式函数。c++11 不允许。当前 c++17 没有报错</span>
    <span class="token function">Test6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Test7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">Test5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="using-别名语法"><a href="#using-别名语法" class="header-anchor">#</a> using 别名语法</h2> <ul><li>可以使用 using 别名 = 类型 的语法取代 typedef 类型 别名 的语法。</li> <li>typedef 语法的局限性
<ul><li>使用实例化类型的别名类型声明变量前，需要先使用 typedef 声明一次。非常麻烦<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> map_int_t<span class="token punctuation">;</span>
map_int_t v1<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> string<span class="token operator">&gt;</span> map_str_t<span class="token punctuation">;</span>
map_int_t v2<span class="token punctuation">;</span>
</code></pre></div></li> <li>如果我们不想使用上面那种麻烦的写法。那么我们可能就需要提前引入模板参数，但这必然导致我们要借助 class 或 struct 的定义来引入该新的模板参数，语法上非常冗余（因为类定义不是我们需要的东西）。例如<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Str_Map</span>
<span class="token punctuation">{</span>
<span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> T<span class="token operator">&gt;</span> type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Str_Map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type map_int_t<span class="token punctuation">;</span>
Str_Map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type map_str_t<span class="token punctuation">;</span>	
</code></pre></div></li> <li>using可以直接引入模板参数传递给实例化类型，不需要借助 class 或 struct。非常优雅<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span>
	
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">using</span> map_str_t <span class="token operator">=</span> map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> T<span class="token operator">&gt;</span><span class="token punctuation">;</span>
	
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    map_str_t<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> m<span class="token punctuation">;</span>
    m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> m<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>first <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> m<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>second <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>using语句无法添加特化版本<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span>

    <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token keyword">const</span> Demo<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">using</span> type <span class="token operator">=</span> T<span class="token punctuation">;</span>

<span class="token comment">// error 想添加一个特化版本，但不允许</span>
<span class="token comment">// template&lt;typename T&gt;</span>
<span class="token comment">// using type&lt;T&amp;&gt; = T;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">remove_reference</span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> type <span class="token operator">=</span> T<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 添加特化版本</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">&amp;</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> type <span class="token operator">=</span> T<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> type <span class="token operator">=</span> T<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Demo d1 <span class="token operator">=</span> remove_reference<span class="token operator">&lt;</span>Demo<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type <span class="token punctuation">{</span>age <span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> name <span class="token operator">:</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    Demo d2 <span class="token operator">=</span> remove_reference<span class="token operator">&lt;</span>Demo<span class="token operator">&amp;</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type <span class="token punctuation">{</span>age <span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span> name <span class="token operator">:</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">/*
        如果没有 remove_reference&lt;T&amp;&amp;&gt; 这个特化版本
        下面这个写法将报错，因为此时将使用 remove_reference 这个通用版本，导致会先实例化一个右值，再调用拷贝构造传递给 d3 
        但拷贝构造被我们显式的删除了
    */</span>
    Demo d3 <span class="token operator">=</span> remove_reference<span class="token operator">&lt;</span>Demo<span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type <span class="token punctuation">{</span>age <span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">,</span> name <span class="token operator">:</span> <span class="token string">&quot;ni hao&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;d1.age = &quot;</span> <span class="token operator">&lt;&lt;</span> d1<span class="token punctuation">.</span>age <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, d1.name = &quot;</span> <span class="token operator">&lt;&lt;</span> d1<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;d2.age = &quot;</span> <span class="token operator">&lt;&lt;</span> d2<span class="token punctuation">.</span>age <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, d2.name = &quot;</span> <span class="token operator">&lt;&lt;</span> d2<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;d3.age = &quot;</span> <span class="token operator">&lt;&lt;</span> d3<span class="token punctuation">.</span>age <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, d3.name = &quot;</span> <span class="token operator">&lt;&lt;</span> d3<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li> <li>函数指针类型的别名类型举例<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token comment">// 普通的函数指针类型的别名类型</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>AddP1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// typedef 语法 在语义上有时难区分 AddP1 是类型还是变量</span>
<span class="token keyword">using</span> AddP2 <span class="token operator">=</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// using 语法 非常清晰</span>
<span class="token keyword">void</span> <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    AddP1 p1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> v1 <span class="token operator">+</span> v2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    AddP2 p2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> v1 <span class="token operator">*</span> v2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> res1 <span class="token operator">=</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> res1 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> res2 <span class="token operator">=</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> res2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 带模板参数的函数指针类型的别名类型</span>
<span class="token comment">/* c++11之前 */</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">FuncT</span> <span class="token punctuation">{</span>
	<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>Func1<span class="token punctuation">)</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">/* c++11 */</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">using</span> Func2 <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 不够优雅</span>
	FuncT<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>Func1 f1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> v1 <span class="token operator">+</span> v2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">// 优雅</span>
	Func2<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> f2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">double</span> d1<span class="token punctuation">,</span> <span class="token keyword">double</span> d2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> d1 <span class="token operator">*</span> d2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="auto-自动推导-编译期"><a href="#auto-自动推导-编译期" class="header-anchor">#</a> auto 自动推导 (编译期)</h2> <ul><li>auto 比较复杂，直接上例子<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// auto 值类型</span>
<span class="token keyword">void</span> <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// int</span>
    <span class="token keyword">auto</span> m <span class="token operator">=</span> <span class="token number">10.2</span><span class="token punctuation">;</span> <span class="token comment">// double</span>
    <span class="token keyword">auto</span> url <span class="token operator">=</span> <span class="token string">&quot;https://www.baidu.com/&quot;</span><span class="token punctuation">;</span> <span class="token comment">// const char* 原生c字符串类型</span>
  
    <span class="token comment">// 向 auto 值类型追加 const (auto 前后均可) 会直接添加 const 属性</span>
    <span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">auto</span> a1 <span class="token operator">=</span> n1<span class="token punctuation">;</span> <span class="token comment">// const int</span>
    <span class="token keyword">int</span> n2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> <span class="token keyword">const</span> a2 <span class="token operator">=</span> n2<span class="token punctuation">;</span> <span class="token comment">// const int</span>
    <span class="token keyword">int</span> n3 <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
    <span class="token comment">// const auto const a3 = 30;  // error</span>
<span class="token punctuation">}</span>

<span class="token comment">// 未指明的 auto 指针与必须指明的 auto 引用</span>
<span class="token keyword">void</span> <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>n1<span class="token punctuation">;</span> <span class="token comment">// int* 对于指针可以不加 * 号</span>
    <span class="token keyword">int</span> n2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span><span class="token operator">&amp;</span> p2 <span class="token operator">=</span> n2<span class="token punctuation">;</span> <span class="token comment">// int&amp; 对于引用必须使用指明&amp;</span>
    <span class="token keyword">auto</span> p3 <span class="token operator">=</span> p2<span class="token punctuation">;</span> <span class="token comment">// int 引用没有使用指明的 auto&amp; 形式，所以推导的还是 int</span>
    <span class="token keyword">auto</span><span class="token operator">&amp;</span> p4 <span class="token operator">=</span> p2<span class="token punctuation">;</span> <span class="token comment">// int&amp;</span>

    <span class="token comment">// 1. 向必须指明的 auto 引用类型前面追加 const (引用只能在前面个追加 const). 直接按字面顺序添加. 2. 引用会保留cv(const或volatile)</span>
    <span class="token keyword">int</span> n5 <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> p5 <span class="token operator">=</span> n5<span class="token punctuation">;</span> <span class="token comment">// const int&amp;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> n6 <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span><span class="token operator">&amp;</span> p6 <span class="token operator">=</span> n6<span class="token punctuation">;</span> <span class="token comment">// const int&amp;. 保留 const 属性</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> n7 <span class="token operator">=</span> <span class="token number">70</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> p7 <span class="token operator">=</span> n7<span class="token punctuation">;</span> <span class="token comment">// const int&amp;. 与保留的 const 属性重合</span>
<span class="token punctuation">}</span>

<span class="token comment">// 顶层 const 与 底层 const</span>
<span class="token keyword">void</span> <span class="token function">Test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> p1 <span class="token operator">=</span> n1<span class="token punctuation">;</span> <span class="token comment">// int 因为 auto 将忽略掉顶层 const (被推导值本身是const, 像值类型与引用类型的const都是顶层 const)</span>

    <span class="token keyword">const</span> <span class="token keyword">int</span> n2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>n2<span class="token punctuation">;</span> <span class="token comment">// const int* 因为 auto 将保留底层 const (被推导值本身不是const,但其指向的值是const. 常量指针的 const 都是底层 const)</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> n3 <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> p3 <span class="token operator">=</span> <span class="token operator">&amp;</span>n3<span class="token punctuation">;</span> <span class="token comment">// const int* 同样是底层 const</span>

    <span class="token comment">// 注意点：未指明的 auto 指针，追加 const (auto 前后均可) 将被视为对指针本身追加（即指针常量）</span>
    <span class="token keyword">int</span> n4 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">auto</span> p4 <span class="token operator">=</span> <span class="token operator">&amp;</span>n4<span class="token punctuation">;</span> <span class="token comment">// int* const.</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> n5 <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">auto</span> p5 <span class="token operator">=</span> <span class="token operator">&amp;</span>n5<span class="token punctuation">;</span> <span class="token comment">// const int* const. 底层 const 以及指针本身是 const</span>
    <span class="token keyword">int</span> n6 <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> <span class="token keyword">const</span> p6 <span class="token operator">=</span> <span class="token operator">&amp;</span>n6<span class="token punctuation">;</span> <span class="token comment">// int* const</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> n7 <span class="token operator">=</span> <span class="token number">70</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> <span class="token keyword">const</span> p7 <span class="token operator">=</span> <span class="token operator">&amp;</span>n7<span class="token punctuation">;</span> <span class="token comment">// const int* const</span>
    <span class="token keyword">int</span> n8 <span class="token operator">=</span> <span class="token number">80</span><span class="token punctuation">;</span>
    <span class="token comment">// const auto const p8 = &amp;n8; // error</span>
<span class="token punctuation">}</span>

<span class="token comment">// 指明的 auto* 类型</span>
<span class="token keyword">void</span> <span class="token function">Test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>n1<span class="token punctuation">;</span> <span class="token comment">// int*. 显式指明指针类型, auto 将推出指针的基类型 int</span>
    <span class="token keyword">int</span> n2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>n2<span class="token punctuation">,</span> m1 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// 同上,auto 推出指针基类型 int. 故 m1 为 int</span>

    <span class="token comment">// 注意点：对于指明 auto* 类型，追加 const 将按照字面顺序追加. 比未指明的 auto 指针好理解</span>
    <span class="token keyword">int</span> n3 <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token operator">&amp;</span>n3<span class="token punctuation">;</span> <span class="token comment">// const int*</span>
    <span class="token keyword">int</span> n4 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span><span class="token operator">*</span> <span class="token keyword">const</span> p4 <span class="token operator">=</span> <span class="token operator">&amp;</span>n4<span class="token punctuation">;</span> <span class="token comment">// int* const</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> n5 <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span><span class="token operator">*</span> p5 <span class="token operator">=</span> <span class="token operator">&amp;</span>n5<span class="token punctuation">;</span> <span class="token comment">// const int* . 底层 const 仍旧保留</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> n6 <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">*</span> p6 <span class="token operator">=</span> <span class="token operator">&amp;</span>n6<span class="token punctuation">;</span> <span class="token comment">// const int*. 底层 const + 指明底层的 const 重合</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> n7 <span class="token operator">=</span> <span class="token number">70</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span><span class="token operator">*</span> <span class="token keyword">const</span> p7 <span class="token operator">=</span> <span class="token operator">&amp;</span>n7<span class="token punctuation">;</span> <span class="token comment">// const int* const. 底层 cosnt + int* const</span>
    <span class="token keyword">int</span> n8 <span class="token operator">=</span> <span class="token number">80</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">*</span> <span class="token keyword">const</span> p8 <span class="token operator">=</span> <span class="token operator">&amp;</span>n8<span class="token punctuation">;</span> <span class="token comment">// 指明的 const int* const</span>
<span class="token punctuation">}</span>

<span class="token comment">// 字面匹配</span>
<span class="token keyword">void</span> <span class="token function">Test5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对于能在字面上对应上的，就直接匹配了</span>
    <span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>n1<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">*</span> <span class="token keyword">const</span> p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span> <span class="token comment">// const int* const</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> p3 <span class="token operator">=</span> n1<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> p4 <span class="token operator">=</span> p3<span class="token punctuation">;</span> <span class="token comment">// const int&amp;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Test6</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 分析题</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span><span class="token operator">&amp;</span> p1 <span class="token operator">=</span> n1<span class="token punctuation">;</span> <span class="token comment">// const int&amp;</span>

    <span class="token comment">// auto&amp; p2 = &amp;p1; // erorr 假如能接收, p2 就是 const int* &amp;. 但很遗憾, &amp;p1(寻址结果）是一个右值，而 auto&amp; 是左值引用，无法接收</span>

    <span class="token comment">/*
        const auto&amp; 是 const 的左值引用所以可以接收右值
        但这个分析顺序比较难, 分析顺序应该是 auto 推出const int*. 追加 const 推出 const int* const
        最后 &amp; 推出 const int* const &amp;
     */</span>
    <span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> p3 <span class="token operator">=</span> <span class="token operator">&amp;</span>p1<span class="token punctuation">;</span> <span class="token comment">// const int* const &amp;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>auto 可以用于返回值。例如<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// c++11 之前我们必须这么写(使用尾返回类型)。但代码变的很 low. 因为我们在调用的时候大部分时间是不知道函数的返回值类型的</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">R</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
R <span class="token function">add</span><span class="token punctuation">(</span>T x<span class="token punctuation">,</span> U y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// c++11 我们可以这么写。至于为什么不把 decltype 写在返回值的位置。因为编译器在读到 x y 时，它的类型是未定义的。所以不行</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span>T x<span class="token punctuation">,</span> U y<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x<span class="token operator">+</span>y
<span class="token punctuation">}</span>

<span class="token comment">// 注：c++14 直接写 auto 就行了</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span>T x<span class="token punctuation">,</span> U y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>auto 的限制
<ul><li>auto 不能在函数的参数中使用</li> <li>auto 不能用于实例成员</li> <li>auto 不能声明为数组的元素类型。例如<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">char</span> url<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">&quot;https://www.baidu.com/&quot;</span><span class="token punctuation">}</span>
<span class="token keyword">auto</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>url<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// error</span>
</code></pre></div></li> <li>auto 不能用于模板参数</li></ul></li></ul> <h2 id="decltype-类型推导-编译期"><a href="#decltype-类型推导-编译期" class="header-anchor">#</a> decltype 类型推导 (编译期)</h2> <ul><li><p>decltype 与 auto 区别在于，auto 是根据等号的右边进行推导，decltype 是根据 () 中的表达式进行推导</p></li> <li><p>() 中表达式必须有结果，并且结果不能为 void</p> <ul><li>()中的表达式并不会进行真正的运算或调用</li></ul></li> <li><p>decltype 举例</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> Number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 注：static成员不可以在类定义体中初始化，但static const可以</span>
    <span class="token keyword">int</span> X<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> x<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> y<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// int</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span> z<span class="token punctuation">{</span>x<span class="token operator">+</span>y<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// int</span>
    <span class="token keyword">const</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token operator">*</span> p<span class="token punctuation">{</span><span class="token operator">&amp;</span>z<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// const int*</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token operator">*</span> pi <span class="token operator">=</span> <span class="token operator">&amp;</span>z<span class="token punctuation">;</span> <span class="token comment">// int*</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span class="token operator">*</span> pp <span class="token operator">=</span> <span class="token operator">&amp;</span>pi<span class="token punctuation">;</span> <span class="token comment">// int**</span>

    <span class="token comment">// decltype 不会像 auto 一样有选择的忽略cv（const或volatile）限定</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> i<span class="token punctuation">{</span>x<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> j<span class="token punctuation">{</span>y<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// const int&amp;</span>
    <span class="token keyword">volatile</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> v <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// volatile int</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>Foo<span class="token double-colon punctuation">::</span>Number<span class="token punctuation">)</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// const int</span>
    Foo foo<span class="token punctuation">;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>X<span class="token punctuation">)</span> c<span class="token punctuation">;</span> <span class="token comment">// int</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span> d <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// int&amp; 如果表达式中是用括号括起来的左值，则得到的是对应的左值引用</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> <span class="token function">int_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">int_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// int 注：这里并不会去调用函数</span>
  <span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">int_func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">int_func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// int&amp;</span>
  <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> <span class="token function">int_func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">int_func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// int&amp;&amp;</span>

  <span class="token keyword">int</span> e <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> f <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">decltype</span><span class="token punctuation">(</span>e <span class="token operator">+</span> f<span class="token punctuation">)</span> g<span class="token punctuation">;</span> <span class="token comment">// int</span>
  <span class="token keyword">decltype</span><span class="token punctuation">(</span>e <span class="token operator">+=</span> f<span class="token punctuation">)</span> h <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// int&amp; 不知道为什么是int&amp;&amp;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="基于范围的-for-循环"><a href="#基于范围的-for-循环" class="header-anchor">#</a> 基于范围的 for 循环</h2> <ul><li>常见形式 (一般搭配 auto，也可以显式指明迭代元素的类型)<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 拷贝循环 可读可写，但不影响迭代目标</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> target<span class="token punctuation">)</span>
<span class="token comment">// 引用循环 性能好，也可以影响迭代目标。注：如果迭代变量本身是 const 那么 auto&amp; 可能是 const auto&amp;. 原因是引用保留 const</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> x <span class="token operator">:</span> target<span class="token punctuation">)</span>
<span class="token comment">// 显式的const引用循环 (常用) 性能好但只能读</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> x <span class="token operator">:</span> target<span class="token punctuation">)</span>
</code></pre></div></li> <li>注意：基于范围的 for 可以迭代 stl 容器。也可以直接迭代数组，但必须让编译器知道确切的范围，例如在函数中使用的数组参数就不可以</li></ul> <h2 id="lambda-表达式"><a href="#lambda-表达式" class="header-anchor">#</a> lambda 表达式</h2> <ul><li>形式<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token punctuation">[</span>capture list<span class="token punctuation">]</span> <span class="token punctuation">(</span>parameter list<span class="token punctuation">)</span> option <span class="token operator">-&gt;</span> <span class="token keyword">return</span> type <span class="token punctuation">{</span> function body<span class="token punctuation">}</span>
</code></pre></div></li> <li>capture list 表示捕获列表，(必须有) 就是 lambda 表达式所在作用域的捕获变量列表。
<ul><li>[] 不捕获任何变量</li> <li>[&amp;] 捕获作用域中所有变量，按引用捕获</li> <li>[=] 捕获作用域中所有变量，按值捕获。
<ul><li>注意可捕获的前提是变量是可拷贝的，值捕获的时机是在 lambda 表达式被创建时，而不是被调用时</li> <li>还有一个很奇葩的点(和java很像)，即便是按值捕获，也是隐式 const 的（即不能改）</li></ul></li> <li>[=,&amp;foo] 按值捕获作用域中所有变量，并按	引用捕获 foo 变量</li> <li>[bar] 只按值捕获 bar 变量</li> <li>[this] 只捕获 this 指针(按值捕获还是引用捕获不重要)。注：如果使用 [&amp;] 或 [=] 默认就会捕获 this 指针</li></ul></li> <li>parameter list 表示参数列表 (这是可选的，如果没有就表示无参)</li> <li>option 是函数选项。(可选的) 可以填 mutable exception attribute
<ul><li>mutable 表示按值捕获的变量可以修改。并且可以访问被捕获对象的非 const 方法</li> <li>exception 表示会抛出异常以及何种异常</li> <li>attribute 用来声明属性 (我不知道是干嘛的)</li></ul></li> <li>return type 返回值类型（可选的）。如果函数体中仅有一个路径的return或者返回值为空，可以不写</li> <li>function body 函数体 (必须有)</li> <li>lambda 表达式是不能被赋值的。例如<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;A&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
a <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// error</span>
<span class="token keyword">auto</span> c <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// ok</span>
</code></pre></div></li> <li>lambda 表达式可以赋值给对应类型的函数指针(仅当没有捕获时). 但我们最常用的还是使用auto. 也可以使用 STL 中 <functional> 头文件提供的一个多态函数对象类型 std::function, 使用恰当的模板实参可以绑定到对应的 lambda 表达式。例如<div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> wrapper <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">&lt;</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></functional></li> <li>经常将 lambda 表达式用作回调函数<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v1 <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">count_if</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> x <span class="token operator">&gt;</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v2 <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> even_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">for_each</span><span class="token punctuation">(</span>v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>even_count<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token operator">++</span>even_count<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> even_count <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>注意点：
<ul><li>引用捕获并不会像其他语言 (例如 c# go) 一样，延长被捕获变量的生命周期。因此仍然有可能出现 dangling references 。例如</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>

std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">add_x</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> x <span class="token operator">+</span> a<span class="token punctuation">;</span> <span class="token comment">// 这里引用捕获的 x 在函数返回之后就被销毁了。所以再次调用的时候 x 是一个垃圾值</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="std-function-与-std-bind"><a href="#std-function-与-std-bind" class="header-anchor">#</a> std::function 与 std::bind</h2> <ul><li>前置知识：可调用对象
<ul><li>c++ 中的可调用对象大致有：函数、函数指针、lambda表达式、成员指针(除了静态成员变量指针)、仿函数、重载了类型转换符为函数指针类型的对象</li></ul></li> <li>由于可调用对象的定义比较多样，c++11 引入了 std::function 和 std::bind 来统一它们</li> <li>std::function 的写法: std::function&lt;返回值类型(参数类型列表)&gt; 变量名 注：std::function 对象的调用就与正常的函数指针变量调用一模一样，不多 BB
<ul><li>对于 c++ 中的可调用对象，除了实例成员指针之外，其他的都能由 std::function 直接接收<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span> <span class="token comment">// 欲使用 std::function 就需要包含 &lt;functional&gt; 头文件</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; + &quot;</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; = &quot;</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">+</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Func1</span><span class="token punctuation">(</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;func1 call ...&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Demo1</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; - &quot;</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; = &quot;</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">-</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">Mul</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; * &quot;</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; = &quot;</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">*</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">double</span> InstanceField<span class="token punctuation">;</span>
    <span class="token keyword">static</span> string StaticField<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
string Demo1<span class="token double-colon punctuation">::</span>StaticField <span class="token operator">=</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Demo2</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; / &quot;</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; = &quot;</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">/</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">using</span> StaticFuncPointer <span class="token operator">=</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等价于 typedef int (*FuncPointer)(double, string);</span>
<span class="token keyword">class</span> <span class="token class-name">Demo3</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> InstanceFuncPointer <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token punctuation">(</span>Demo3<span class="token double-colon punctuation">::</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>string <span class="token punctuation">,</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 妈的用到了 Demo3 类标识符，所以需要提前声明</span>
<span class="token keyword">class</span> <span class="token class-name">Demo3</span> <span class="token punctuation">{</span> <span class="token comment">// 重载了类型转换符为函数指针的类</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">StaticPrint</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span> string b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;a = &quot;</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, b = &quot;</span>  <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">InstancePrint</span><span class="token punctuation">(</span>string a<span class="token punctuation">,</span> string b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;a = &quot;</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, b = &quot;</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 重载类型转换符，且转换目标为函数指针类型</span>
    <span class="token keyword">operator</span> <span class="token function">StaticFuncPointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token comment">// 类型转换符函数必须无参，且不写返回类型，因为返回类型就是这个类型转换符。并且这种成员函数一般带 const</span>
        <span class="token keyword">return</span> Demo3<span class="token double-colon punctuation">::</span>StaticPrint<span class="token punctuation">;</span> <span class="token comment">// 注：这里不能返回实例成员函数，因为常规函数指针无法接收实例成员函数的，但可以接收静态成员函数</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">operator</span> <span class="token function">InstanceFuncPointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">&amp;</span>Demo3<span class="token double-colon punctuation">::</span>InstancePrint<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
    <span class="token comment">// 接收普通函数</span>
    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> f1 <span class="token operator">=</span> Add<span class="token punctuation">;</span> <span class="token comment">// ok 接收普通函数</span>

    <span class="token comment">// 接收函数指针</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>p1<span class="token punctuation">)</span><span class="token punctuation">(</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> Func1<span class="token punctuation">;</span>
    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> f2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>

    <span class="token comment">// 接收 lambda 表达式。即便是有捕获的lambda 表达式，std::function 也能接收</span>
    function<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token operator">&gt;</span> f3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">,</span> string c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, &quot;</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, &quot;</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// 接收成员指针</span>
    <span class="token comment">// function&lt;int(int, int)&gt; f4 = &amp;Demo1::Sub; // erorr 不允许直接接收实例成员函数 ，因为实例成员函数依赖实例对象</span>
    <span class="token comment">// function&lt;double(void)&gt; f5 = &amp;Demo1::InstanceField; // error 不允许直接接收实例成员变量指针，因为实例成员变量指针依赖实例对象</span>
    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> f6 <span class="token operator">=</span> <span class="token operator">&amp;</span>Demo1<span class="token double-colon punctuation">::</span>Mul<span class="token punctuation">;</span> <span class="token comment">// ok 接收静态成员函数</span>
    <span class="token comment">// function&lt;string(void)&gt; f7 = &amp;Demo1::StaticField; // error 不允许接收静态成员变量指针。因为静态成员变量指针不属于可调用对象</span>

    <span class="token comment">// 接收仿函数</span>
    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> f7 <span class="token operator">=</span> <span class="token function">Demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意到右值也可以接收</span>

    <span class="token comment">// 接收可转函数指针类型的对象</span>
    Demo3 demo3<span class="token punctuation">;</span>
    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token operator">&gt;</span> f8 <span class="token operator">=</span> demo3<span class="token punctuation">;</span>
    <span class="token comment">// function&lt;void(string, string)&gt; f9 = demo3; // error 不允许接收可转实例成员函数指针类型的对象</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>std::function 作为回调函数的例子<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> callback<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> f<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">callback</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">Notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;我是要成为海贼王的男人&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    B b<span class="token punctuation">;</span>
    A <span class="token function">a</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    a<span class="token punctuation">.</span><span class="token function">Notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li> <li>std::bind 的作用是将可调用对象与对应的 [实例] 参数进行绑定，返回一个仿函数对象，而且通常我们会用 std::function 去接收它。
<ul><li>std::bind 可通过位置形参的实参占位符或者固定参数值（固定参数值比实参的优先级高），来动态定制可调用对象的调用形式</li> <li>std::bind 允许将实例成员指针进行绑定，从而实现让 std::function 间接地接收实例成员指针</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">OutPut</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;x = &quot;</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, y = &quot;</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 灵活定制可调用对象地调用形式</span>
<span class="token keyword">void</span> <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>OutPut<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 绑定固定参数值，随后调用</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>OutPut<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第一个形参绑定第1个实参，随后调用</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>OutPut<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第二个形参绑定第1个实参，随后调用</span>
    <span class="token comment">// std::bind(OutPut, std::placeholders::_2, 2)(10); // error 第一个形参绑定第2个实参，但并没有传第二个实参</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>OutPut<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第一个形参是固定参数值，优先级高，所以第1个实参没有使用。第二个形参绑定第2个实参</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>OutPut<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10, 20</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>OutPut<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_2<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20, 10</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Demo::Print =&gt; &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;x = &quot;</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, y = &quot;</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span> InstanceField<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 用 std::bind 将实例成员指针与实例、参数绑定. 将返回的仿函数对象传递给 std::function</span>
<span class="token keyword">void</span> <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Demo demo<span class="token punctuation">;</span>
    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> f1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Demo<span class="token double-colon punctuation">::</span>Print<span class="token punctuation">,</span> <span class="token operator">&amp;</span>demo<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 绑定实例成员函数指针 需要将实例地址传入第二个参数中</span>
    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> f2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Demo<span class="token double-colon punctuation">::</span>InstanceField<span class="token punctuation">,</span> <span class="token operator">&amp;</span>demo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 绑定实例成员变量指针. 因为是绑定变量，所以参数声明为void,返回值声明为左值引用（左值语义）</span>

    <span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> demo<span class="token punctuation">.</span>InstanceField <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="final-关键字"><a href="#final-关键字" class="header-anchor">#</a> final 关键字</h2> <ul><li>final 关键字的作用和 java 中的 final 关键字是一样的，只不过放到后面。用来修饰虚函数不能被重写，或者是类不能被继承<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Base class ...&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">final</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Child class ...&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">GrandChild</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Child</span></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// error</span>
    <span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;GrandChild class ...&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Base class ...&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">final</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Child class ...&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// error</span>
<span class="token keyword">class</span> <span class="token class-name">GrandChild</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Child</span></span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <h2 id="override-关键字"><a href="#override-关键字" class="header-anchor">#</a> override 关键字</h2> <ul><li>override 关键字和 c# 中 override 关键字的作用是一致的，只不过要放在后面。明确的告诉编译器我要重写虚函数。提高代码的可读性，以及确保重写时函数签名是正确的<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Base class ...&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Child class ...&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">GrandChild</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Child</span></span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;GrandChild class ...&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <h2 id="委托构造函数"><a href="#委托构造函数" class="header-anchor">#</a> 委托构造函数</h2> <ul><li>C++11 引入委托构造，可以在构造函数先调用同一个类中的另一个构造函数 (其他语言早都有了)<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token keyword">int</span> value1<span class="token punctuation">;</span>
<span class="token keyword">int</span> value2<span class="token punctuation">;</span>
<span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    value1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 委托 Base() 构造函数</span>
    value2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li>我们通常会先准备一个最全的构造函数，然后其他不那么全的构造函数去根据需要调用它。或者是迭代式的（少见）</li> <li>委托构造函数的限制：
<ul><li>链式调用不能形成一个环，否则将在运行时抛异常</li> <li>委托构造函数不能和成员初始化列表一起使用，注意是委托构造，不是基类的构造调用，基类，基类的构造的调用不受限制可以和成员初始化列表一起使用。</li></ul></li></ul> <h2 id="继承构造函数"><a href="#继承构造函数" class="header-anchor">#</a> 继承构造函数</h2> <ul><li>子类在继承父类的时候是没有继承父类的构造函数的。但是 c++11 引入了 using 语句可以实现继承。并且是不使用是不会产生函数代码，比传统的透传方式相对更省代码空间</li> <li>继承构造函数的举例<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
  
<span class="token keyword">namespace</span> demo <span class="token punctuation">{</span>
<span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
  
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;A defualt parameter constructor call... a = &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>a <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;A constructor(int, const char*) call... a = &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>a <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, s = &quot;</span> <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
  
<span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> A<span class="token double-colon punctuation">::</span>A<span class="token punctuation">;</span> <span class="token comment">// 将 A 的构造函数都虚继承下来。不使用则不产生函数代码</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span> <span class="token comment">// 使用继承构造函数的时候，对于子类新增的成员变量，只能使用默认初始化的方式。</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
  
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    demo<span class="token double-colon punctuation">::</span>B b1<span class="token punctuation">;</span> <span class="token comment">// 调用的是父类的默认参数构造函数</span>
    demo<span class="token double-colon punctuation">::</span>B <span class="token function">b2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用的还是父类的默认参数构造函数</span>
    demo<span class="token double-colon punctuation">::</span>B <span class="token function">b3</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用的是父类的普通构造函数</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>继承构造函数的限制：
<ul><li>子类实例化时调用的永远是父类的构造函数，所以导致子类自己新增的成员变量无法体现在构造函数的参数列表中。</li> <li>使用继承构造函数，子类的的默认构造函数将消失</li></ul></li> <li>最佳使用场景：派生类只是在基类的基础上添加了新函数的情形</li></ul> <h2 id="using-打开同名隐藏函数"><a href="#using-打开同名隐藏函数" class="header-anchor">#</a> using 打开同名隐藏函数</h2> <ul><li>c++ 中子类的同名函数会隐藏父类的所有重载版本，我们可以使用与继承构造函数一样的语法形式，将隐藏关闭。注: 不是必须使用 using 语句才能访问被隐藏同名函数，使用传统的 对象.基类::成员 也可以访问<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Base Func ...&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Base Func i = &quot;</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> string str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Base Func i = &quot;</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, str = &quot;</span> <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>Func<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Son Func ...&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Son son<span class="token punctuation">;</span>
    son<span class="token punctuation">.</span><span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Son Func ... 说明同一个函数签名的还是被隐藏了</span>
    son<span class="token punctuation">.</span><span class="token function">Func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    son<span class="token punctuation">.</span><span class="token function">Func</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="static-assert"><a href="#static-assert" class="header-anchor">#</a> static_assert</h2> <ul><li>普通的断言，需要包含头文件 <cassert> 。断言发生在运行时，且我们无法自定义错误信息
<ul><li>所谓断言，就是总是期望某个布尔表达式为 true，否则就报错</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cassert&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">createArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>size <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// assert 是一个宏。我断定 size &gt; 0, 否则程序将中断</span>
    <span class="token keyword">char</span><span class="token operator">*</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> array<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span><span class="token operator">*</span> buf <span class="token operator">=</span> <span class="token function">createArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></cassert></li> <li>静态断言，不需要包含头文件。并且断言发生在编译时，且我们可以自定义错误信息。
<ul><li>因为发生在编译时，所以我们不能使用变量表达式。只能使用常量表达式</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">static_assert</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">&quot;断言失败，这不是我希望的 32 位平台&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;当前平台 long 的大小: &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 4 说明断言成功</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;64 位指针大小: &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="noexcept-关键字"><a href="#noexcept-关键字" class="header-anchor">#</a> noexcept 关键字</h2> <ul><li>c++ 异常语法参考文章: https://blog.csdn.net/newson92/article/details/113875276</li> <li>noexcept关键字 参考文章: https://subingwen.cn/cpp/noexcept/</li></ul> <h2 id="右值引用"><a href="#右值引用" class="header-anchor">#</a> 右值引用</h2> <ul><li><p>左值和右值：左值就是可寻址 (&amp;) 的值。右值就是临时值，不可寻址，右值又分为纯右值和将亡值。</p> <ul><li>左值与右值是值语义概念，影响的是语法检查。但并不是与存储位置相关的物理概念，和物理存储没半毛钱关系</li> <li>将亡值，①非引用类型的返回值本身（特指返回过程中产生的临时值，但该临时值有可能被编译器优化掉了，但不影响这个结论）②被右值引用所绑定的临时值 ③转换为右值引用类型&quot;后&quot;的那个临时结果本身（相当于源值物理存储不变但语义改变，我给它取名叫将亡右值）例如 static_cast&lt;某类型&amp;&amp;&gt;(实参) 这个调用结果
<ul><li>①中将亡体现在该返回值本身即将消亡，但可借助后续移动操作传承下去 ②中将亡体现在所绑定的临时值原来即将消亡，但通过引用的方式重新续命，并且后续可进行移动操作传承下去 ③中将亡体现在后续经常要对转换&quot;后&quot;的这个将亡右值进行移动操作传承下去，源值也会随移动操作&quot;消亡&quot;
<ul><li>从中可以看出将亡值的定义与&quot;可能移动的预备值&quot;的语境息息相关。</li> <li>③中：如果转换&quot;前&quot;是源右值，那这个源右值是属于将亡右值，是妥妥的右值；如果转换前是源左值，那这个源左值就是将亡左值，是妥妥的左值，不具有右值语义，因为左值是不可直接移动的，必须借助static_cast或者是std::move转换成右值引用类型，即带有右值语义的将亡右值，后续可进行移动操作。</li></ul></li></ul></li> <li>纯右值基本可以认为是右值的全集，就是表达值的临时性。字面值（字符串字面量除外）以及大多数表达式产生的结果本身。
<ul><li>可以将特定语境下的纯右值看成是将亡值，例如将一个纯右值绑定到右值引用</li> <li>将亡值和纯右值不过是c++标准委员会杜撰出来的概念，并且实际开发中只需要管左值和右值的区别</li> <li>总的来看，纯右值就是纯粹的描述某个值的临时性，将亡值就是在&quot;可能移动的预备值&quot;的语境下讨论的纯右值罢了</li></ul></li> <li>实际开发中非常不建议用总结出来的死规则去区别将亡值和纯右值，强烈建议凭借经验搭配下面几条判定来区分左值和右值即可:
<ol><li>一切可寻址的都是左值，否则都是右值</li> <li>所有变量都是左值，所有临时值都是右值</li> <li>左值引用类型本身以及右值引用类型本身分别具有左值和右值的语义，这里不涉及变量。</li></ol></li></ul></li> <li><p>关于左值、右值、左值引用、右值引用，以及带 const 修饰的各种转换关系</p> <ul><li><p>左值能接收【const】左值【引用】和【const】右值【引用】</p></li> <li><p>左值引用能绑定左值【引用】，不能绑定右值，但可绑定右值引用的变量 (原因是所有变量都被视为左值)。</p> <ul><li>简单来说左值引用能接收所有变量，唯独不能接收右值</li></ul></li> <li><p>右值引用初始化时只能绑定右值，连右值引用变量都不能接收（原因是所有变量被视为左值）。右值引用类型初始化之后的变量的性质和左值差不多。</p></li> <li><p>const 左值引用什么都能接收，const 右值引用初始化时同样只能接收右值。但是 const 是不能改的</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> value <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span> <span class="token comment">// 520 是一个右值 int&amp;&amp; 是一个右值引用</span>

<span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">MyClass</span><span class="token punctuation">(</span>string str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ordinary constructor&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyClass<span class="token operator">&amp;</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;copy constructor&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

MyClass <span class="token function">GetObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 此处返回值是一个右值</span>
    <span class="token keyword">return</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a1<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// int&amp;&amp; a2{a1}; // error</span>
    MyClass c1 <span class="token operator">=</span> <span class="token function">GetObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
    <span class="token comment">// MyClass&amp; c2 = GetObj(); // error 左值引用不能引用右值</span>
    MyClass<span class="token operator">&amp;&amp;</span> c3 <span class="token operator">=</span> <span class="token function">GetObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
    <span class="token keyword">const</span> MyClass<span class="token operator">&amp;</span> c4 <span class="token operator">=</span> <span class="token function">GetObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok 万能的 const 左值引用. 可接收左值、右值、常量左值、常量右值</span>
    <span class="token comment">// 本例中拷贝构造函数一次都没有调用过</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li> <li><p>右值引用也是起别名，只不过是给右值取别名。右值引用变量一旦绑定右值成功（初始化成功），相当于为这个临时的右值 &quot;续命&quot;，延长了其生命周期</p> <ul><li>此时允许我们对该右值引用类型的变量进行取地址、赋值操作，此时得到的是绑定的右值地址以及操作的是绑定的右值</li> <li>有一个稍微反直觉的点，右值引用类型的变量是左值（但利用c++库函数可以查出来是右值引用类型）。注：c++中一切变量都是左值（所以可以寻址）!</li> <li>右值引用类型做为返回值可表达右值语义，因为它的函数调用结果完全符合**转换为右值引用类型&quot;后&quot;**的那个临时结果本身（带有右值语义的将亡右值）。经典的例子就是 std::move 的返回值是一个右值引用类型，可表达std::move的调用结果为一个右值。类似的，左值引用类型做为返回值可表达左值语义，可表达调用结果为一个左值。这个知识点其实是经常用的到的，因为它们不仅分别带有右值和左值的语义，更关键的是它们带有引用的语义，意味着不会对源值进行复制或移动操作，仅仅只是语义变换
<ul><li>简单点记，就是右值引用类型本身和左值引用类型本身分别具有左值和右值的语义</li></ul></li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> i1 <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> i1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 520</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>i1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 0x1f16fffa84</span>
    i1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// ok 使用右值重新赋值</span>
    cout <span class="token operator">&lt;&lt;</span> i1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 100</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>i1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 0x1f16fffa84</span>

    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    i1 <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// ok 使用左值重新赋值。可以看得出右值引用绑定成功之后几乎跟左值一样了</span>
    cout <span class="token operator">&lt;&lt;</span> i1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 20</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>i1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 0x1f16fffa84</span>
    
    <span class="token comment">// int&amp;&amp; i2 = i1; // error 编译器提示错误：无法将右值引用绑定到左值。基本确定右值引用绑定成功之后就是隐式的左值</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>并非所有 &amp;&amp; 都是右值引用，在<strong>函数中</strong>， T&amp;&amp; 和 auto&amp;&amp; 就是不确定的</p> <ul><li>此时叫通用引用（universal reference)。仅当通过右值去推导时， T&amp;&amp; 和 auto&amp;&amp; 才是右值引用。其他情况都是左值引用。注意实参的const会被保留</li> <li>使用 T&amp;&amp; 时还需要注意此时模板（类型）参数 T 本身可能是左值引用类型或者是基类型，这个很重要，当 T 需要转发时，就会体现出来。</li> <li>当T作为类模板的模板参数时，T&amp;&amp;就不是通用引用。例子请参考 std::remove_reference （在 move 函数那一节）</li> <li>const T&amp;&amp; 或 const auto&amp;&amp; 一定是右值引用</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;type_trait&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">Func1</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 一定是右值引用</span>

<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">TestUniversalReference</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用 is_lvalue_reference&lt;&gt; 这个函数需要包含头文件 &lt;type_traits&gt;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Type of arg: &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_lvalue_reference<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">?</span> <span class="token string">&quot;lvalue reference&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;rvalue reference&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Type of T: &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_lvalue_reference<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">?</span> <span class="token string">&quot;lvalue reference&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;non-lvalue reference&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Is T the base type int: &quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>is_same<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">TestFromChatGPT</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
      当传入一个左值时，arg 是左值引用类型，通用引用(Universal Reference) T&amp;&amp; 的模板参数 T 将是左值引用类型
      当传入一个右值时，arg 是右值引用类型，T&amp;&amp; 的模板参数 T 将是引用的基类型
    */</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token function">TestUniversalReference</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">TestUniversalReference</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Func1(x); // error const T&amp;&amp; 一定是右值引用类型</span>
    <span class="token function">Func1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">1314</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> v1 <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// 左值引用</span>
    <span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> v2 <span class="token operator">=</span> <span class="token number">250</span><span class="token punctuation">;</span> <span class="token comment">// 右值引用</span>
    <span class="token comment">// decltype(x)&amp;&amp; v3 = y; // error 右值引用</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> a1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 右值引用</span>
  <span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> bb <span class="token operator">=</span> a1<span class="token punctuation">;</span> <span class="token comment">// 左值引用 注：右值引用 a1 在后续使用的时候会隐式的视为左值</span>
  <span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> bb1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 右值引用</span>

  <span class="token keyword">int</span> a2 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span><span class="token operator">&amp;</span> a3 <span class="token operator">=</span> a2<span class="token punctuation">;</span> <span class="token comment">// 左值引用</span>
  <span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> cc <span class="token operator">=</span> a3<span class="token punctuation">;</span> <span class="token comment">// 左值引用</span>
  <span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> cc1 <span class="token operator">=</span> a2<span class="token punctuation">;</span> <span class="token comment">// 左值引用</span>

  <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> s1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 常量左值引用</span>
  <span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> dd <span class="token operator">=</span> s1<span class="token punctuation">;</span> <span class="token comment">// 常量左值引用</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> s2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 常量右值引用</span>
  <span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> ee <span class="token operator">=</span> s2<span class="token punctuation">;</span> <span class="token comment">// 常量左值引用</span>

  <span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 常量右值引用</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>由 &amp;&amp; 不定以及右值引用变量是左值行为导致的 &quot;在转发中产生逻辑 bug&quot;。此问题可使用 std::forward 来解决</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;左值引用&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;右值引用&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;const 左值引用&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;const 右值引用&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">Forward</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Func</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 转发</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Forward</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传入右值，转发却调用 Func(int&amp;). 因为 t 虽然表面上是右值引用类型，但却视为左值</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token function">Forward</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传入左值，转发调用 Func(int&amp;)</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token function">Forward</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传入 const 左值，调用 Func(const int&amp;)</span>
    <span class="token function">Forward</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传入 const 右值，转发却调用 Func(const int&amp;)</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="移动构造函数-右值引用的运用"><a href="#移动构造函数-右值引用的运用" class="header-anchor">#</a> 移动构造函数(右值引用的运用)</h2> <ul><li>问题背景：某些情况下，临时对象（右值）与接收对象之间得拷贝非常影响性能<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span><span class="token operator">*</span> num<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">num</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;默认构造函数...&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token keyword">const</span> Demo<span class="token operator">&amp;</span> d<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">num</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>d<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 深拷贝</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;拷贝构造函数...&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token operator">~</span><span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;析构函数...&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Demo <span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Demo demo<span class="token punctuation">;</span>
    <span class="token keyword">return</span> demo<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
        在 c++11 之前调用这个函数获取返回值得时候，可能得步骤：
        demo 构造 -&gt; demo 拷贝构造给临时的返回值对象 -&gt; demo 析构
        -&gt; 临时的返回值对象拷贝构造给 d -&gt; 临时的返回值对象析构 -&gt; d 析构

        如果说这个类本身占用是非常大的,那么将会造成极大的性能拖累
    */</span>
    Demo d <span class="token operator">=</span> <span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>c++11 引入移动构造，可以将对象与临时对象（或者说临时右值）之间的传递写成浅拷贝，将临时对象的资源所有权转移到对象，避免不必要的拷贝。
<ul><li>移动构造函数的核心思想就是专门用来接收右值来初始化自己（将右值的资源所有权转移给自己）</li> <li>其实这个做法在拷贝构造函数中也能实现，但拷贝构造只能有一个重载版本，比较珍贵，所以我们常将它改写成深拷贝。</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span><span class="token operator">*</span> num<span class="token punctuation">;</span>
    <span class="token keyword">double</span> height<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">num</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;默认构造函数...&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token keyword">const</span> Demo<span class="token operator">&amp;</span> d<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">num</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>d<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">height</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>height<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 深拷贝</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;拷贝构造函数...&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 注：注意仅限右值传入，且当使用右值初始化对象的时候，移动构造函数的优先级高于拷贝构造函数. 注意移动构造函数不允许抛出异常所以要添加 noexcept</span>
    <span class="token function">Demo</span><span class="token punctuation">(</span>Demo<span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token operator">:</span> <span class="token function">num</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">height</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>height<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 浅拷贝</span>
        temp<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// 通常为了更贴近 &quot;转移&quot; 的语义。 我们会将临时对象转移之后资源所有权置空. 并且这种做法可以防止临时对象的析构函数将资源释放掉</span>
        d<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;移动构造函数...&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token operator">~</span><span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;析构函数...&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Demo <span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Demo demo<span class="token punctuation">;</span>
    <span class="token keyword">return</span> demo<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 此时初始化对象不会将临时对象拷贝过来，只会将资源所有权从临时兑现对象转移过来</span>
    Demo d <span class="token operator">=</span> <span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>注：本例中可能看不到移动构造函数被调用了，其实是因为 现代c++ 编译器默认开启了 NRVO 或 RVO 优化，直接将 Get 函数体中的局部变量、临时变量、以及外部实例化变量之间的所有移动或拷贝的过程给干掉了，很牛逼。但这个优化并不总是生效的，只有编译器在编译阶段能检查出来局部变量或返回值临时变量，才可能会生效，比如你写上一些逻辑判断，编译器就不会检查从而不会生效。所以为了性能考虑，移动构造函数我们强烈建议写上，并且拷贝构造也写，作为备用措施。注：我们也可以在编译参数中加上 -fno-elide-constructors 关闭这个优化，但不建议</li></ul></li> <li>移动操作通常实现的效果是前一个对象的资源所有权移动到了下一个对象，意味着移动后源对象是无意义的（或者说有效但未定义的状态），这个我们需要注意，最好是不要再使用了</li> <li>除了移动构造函数之外，还有移动赋值函数。原理都是类似的，不赘述了</li></ul> <h2 id="std-move-函数"><a href="#std-move-函数" class="header-anchor">#</a> std::move 函数</h2> <ul><li>在很多时候我们需要将一个左值语义的值转成右值语义，就需要借助std::move函数转成右值引用类型（将亡右值）从而具有右值语义。注：move 函数不仅能接收左值也能接收右值，不管怎样最终结果都是提供右值的语义转换</li> <li>这个 move 函数取名取得不好，只是单纯的提供右值语义而已，并没有发生任何的移动或拷贝。仅仅是为后续发生真正的移动提供一个条件。如果说想要真正的实现移动的语义，那么要求类对象本身具有移动构造或者移动赋值函数才行，这两个函数才是真正的移动操作。<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token comment">// move 函数的源码。本质上就是一个强制类型转化成右值引用类型而已</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">constexpr</span> <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span> <span class="token function">move</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Demo demo<span class="token punctuation">;</span>
    <span class="token comment">// Demo&amp;&amp; d1 = demo; // error</span>
    Demo<span class="token operator">&amp;&amp;</span> d2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>demo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
<span class="token punctuation">}</span>

<span class="token comment">// std::remove_reference 的各种版本源码. 专门用来只获取各种类型的基类型</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">remove_reference</span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> type <span class="token operator">=</span> T<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 特化的版本</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">&amp;</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 注意：特化的版本要想存在，原始版本必须存在</span>
    <span class="token keyword">using</span> type <span class="token operator">=</span> T<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> type <span class="token operator">=</span> T<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <h2 id="std-forward-函数"><a href="#std-forward-函数" class="header-anchor">#</a> std::forward 函数</h2> <ul><li>问题背景：&amp;&amp; 的不定以及右值引用类型的变量被视为左值(引用折叠)，所以给后续的转发造成逻辑 bug。</li> <li>forward 函数也是一个单纯的类型转换，提供左值或者是右值的语义转换，同样没有转发的意思。也没有发生移动或拷贝，这里应该归功于 &quot;左值引用类型与右值引用类型不仅分别带有左值和右值的语义，而且还带有引用的语义&quot;。</li> <li>forward 函数不使用实参来确定最终的语义转化，而是由模板实参决定。
<ul><li>当实参是左值时，才提供左值或右值的语义转换，且仅当模板实参是左值引用类型时，才时左值的语义转换，其余都是右值的语义</li> <li>当实参是右值时，只能右值的语义转换，因为它的函数体中不允许模板实参是左值引用类型。</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// forward 函数的源码</span>

<span class="token comment">// 这里返回值使用 T&amp;&amp; 而不用 T 的原因是 T&amp;&amp; 必定带有引用的语义，所以不会发生拷贝或移动。注: T&amp;&amp;&amp; 等价于 T&amp; 。 T&amp;&amp;&amp;&amp; 等价于 T&amp;&amp;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token comment">// t 只能接收左值，提供左值或右值的语义转换</span>
<span class="token keyword">constexpr</span> T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token comment">// 请清楚一点，右值引用类型的变量也是左值，也传入这个重载</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token comment">// t 只能接收右值，且只能提供右值的语义转换</span>
<span class="token keyword">constexpr</span> T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
    <span class="token comment">// 模板实参不允许是左值引用类型</span>
    <span class="token keyword">static_assert</span><span class="token punctuation">(</span><span class="token operator">!</span>std<span class="token double-colon punctuation">::</span>is_lvalue_reference<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span> <span class="token string">&quot;template argument substituting T is an lvalue reference type&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>有了 forward 函数之后，我们就可以避免当 T&amp;&amp; (Uninversal Reference) 类型的变量是右值引用类型的变量，但却视为左值的问题。实现将 T&amp;&amp; 类型的变量完美转发<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;接收了左值&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;接收了右值&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">Previous</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Func</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 转发</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token function">Previous</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 接收了左值</span>
    <span class="token function">Previous</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 接收了右值</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="特殊成员函数"><a href="#特殊成员函数" class="header-anchor">#</a> 特殊成员函数</h2> <ul><li>从 c++11 开始，共有六个特殊的成员函数：默认构造、析构函数、拷贝构造、拷贝赋值、移动构造、移动赋值。这些特殊的成员函数可由编译器自动隐式生成
<ul><li>这些特殊成员函数都是 public 且 inline 的，其中拷贝构造和拷贝赋值代表拷贝操作，移动构造和移动赋值代表移动操作</li> <li>移动操作优先级高于拷贝操作，当无法执行移动操作的时候，就转而执行拷贝操作</li> <li>所有析构函数都是隐式 noexcept 的，因此绝不允许向外抛出异常。我们不仅要注意在析构函数中处理显式的 throw 异常，还得处理析构函数体内部调用的函数所抛出的异常</li></ul></li> <li>特殊成员函数的默认生成规则
<ul><li>这些特殊成员函数如果用户手动提供，那对应默认的将不会由编译器自动隐式生成</li> <li>默认构造函数是不需要任何实参就能调用的构造函数（可能是无参或者是全部参数都是默认参数）
<ul><li>当用户手动提供任何构造函数，自动生成的默认构造将被删除</li> <li>当基类的默认构造函数无法调用的时候，自动生成默认构造函数将被 deleted</li></ul></li> <li>自动生成的析构函数的行为是将对象的所有实例成员进行析构，仅当基类的析构函数为虚析构的时候，它才是虚析构。</li> <li>自动生成的拷贝操作行为是浅拷贝，但我们通常会手动改写成深拷贝
<ul><li>当用户手动提供移动操作，那么自动生成的拷贝操作将被 deleted</li> <li>用户手动提供的拷贝构造 &quot;不会&quot; 造成自动生成的拷贝赋值被 deleted ，反之一样</li></ul></li> <li>自动生成的移动操作的行为是能移动就移动，不能移动就拷贝。
<ul><li>当用户手动提供了拷贝操作，那么自动生成的移动操作将被 deleted。</li> <li>当用户手动提供移动构造，自动生成的移动赋值将 &quot;会&quot; 被 deleted，反之也是。
<ul><li>这种规则会导致如果用户使用 = delete 标记移动操作，那么所有默认生成的移动操作和拷贝操作都被 deleted</li></ul></li></ul></li> <li>当类中有 const 实例成员或者是引用成员，且该成员没有初始化，自动生成的默认构造将被 deleted 。注：const 实例成员和引用成员的初始化方式，只能用就地初始化或者是靠成员初始化列表
<ul><li>原因是 const 实例成员和引用成员必须初始化，而自动生成的默认构造无法做到</li></ul></li> <li>当类中有 const 实例成员或者是引用成员，自动生成的赋值操作将被 deleted
<ul><li>注意此时自动生成构造（复制或移动）操作仍然不会被deleted. 并且它们对const实例成员或者引用成员的初始化仍然采用的是成员初始化列表方式</li></ul></li></ul></li></ul> <h2 id="default-与-delete"><a href="#default-与-delete" class="header-anchor">#</a> = default 与 = delete</h2> <ul><li><p>引入背景：手动提供了一些特殊的成员函数，可能干掉默认生成的特殊成员函数。但我们想显式的控制这些特殊成员函数的默认生成或删除</p></li> <li><p>使用 = default 关键字让编译器强制为我们生成默认的特殊成员函数、使用 = delete 关键字 让编译器强制删除默认的特殊成员函数</p></li> <li><p>使用 = default 或者 = delete 关键字后，该特殊成员函数将继续参与 &quot;特殊成员函数的默认生成规则&quot;。这是一个极大的 bug</p></li> <li><p>= delete 还有一个极大的 bug，使用后该特殊成员函数继续参数重载决议，导致该特殊成员函数仍有机会优先匹配到但却无法调用的矛盾结果。</p></li> <li><p>使用 = delete 关键字会对派生类造成影响，但该特殊成员函数将不参数重载决议。</p></li> <li><p>= default 函数比我们手动写的执行效率更高</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>特殊成员函数原型 <span class="token operator">=</span> defualt<span class="token punctuation">;</span>

特殊成员函数原型 <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>= delete 关键字不仅用在特殊成员函数上，也可以用在普通成员函数上。</p></li> <li><p>当我们完全使用这两个关键字进行编码时，就可以极大的降低 &quot;特殊成员函数的默认生成规则&quot; 对代码造成的影响，因为此时的代码意图是非常明确的</p></li></ul> <h2 id="std-shared-ptr"><a href="#std-shared-ptr" class="header-anchor">#</a> std::shared_ptr</h2> <ul><li>共享指针是三大智能指针之一，它的行为与 c# 和 java 的一样，经常使用多个共享指针引用同一个资源。</li> <li>请理解 c++ 智能指针，智能指针是用来托管原始指针的语法工具，但它这个托管的原理与其他语言托管的原理是不同的，它不依赖 GC 而只是单纯的使用共享指针类自身的算法，所以性能很好</li> <li>内部使用计数来决定资源是否被释放，当资源被引用的计数为 0 时，资源将由c++ 自动回收。原理：每个 shared_ptr 对象在析构的时候会检查引用计数，如果非 0 仅析构自身，如果是 0 就顺便 delete 内部托管的原始指针。</li> <li>共享指针也只是个模板类对象，它重载了指针的各种方法，相当于仿指针。同时它也有自己的很多方法（比如直接用 . 访问的那些）</li> <li>共享指针的初始化<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span> <span class="token comment">// 需要引入 &lt;memory&gt; 头文件</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// 使用普通构造函数初始化</span>
<span class="token keyword">void</span> <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模板实参为资源类型，参数为资源的指针</span>
    cout <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 常用 use_count 方法来统计该资源被共享指针引用的次数</span>

    <span class="token comment">// 使用共享指针管理字符数组的堆内存</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token function">ptr2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// 仅声明且实例化共享指针对象，但它未定义（未初始化管理内存）</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr3<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> ptr3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 0</span>

    <span class="token comment">// 创建共享指针对象，但管理的内存为空</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr4</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> ptr4<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 0</span>

    <span class="token comment">// 注：不要使用同一个原始指针初始化多个智能指针</span>
    <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p1</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// shared_ptr&lt;int&gt; p2(p); // 如果传入同一个原始指针，p2 将不会知道自己与其他 shared_ptr 共享资源。当 p2 析构的时候会将内部托管的原始指针进行 delete , 导致 p1 内部托管的原始指针变成一个悬垂指针，进而导致 p1 析构的时候重复释放而抛异常。高版本的 c++ 可能会纵容这个异常让程序继续运行，但从程序的 exit code 中可以看到不为 0</span>

    <span class="token comment">// 不要使用即将被回收的内存的指针来初始化智能指针</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p3</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 原理同上，还是重复释放。至于先释放 x 还是先从智能指针的析构中释放，不重要</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用（拷贝或移动）构造函数进行初始化</span>
<span class="token keyword">void</span> <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 1</span>

    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr2</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用拷贝构造，将 ptr1 本身复制给 ptr2</span>
    cout <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 2</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr3 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 3</span>

    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr4</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用移动构造函数。将 ptr1 本身移动给 ptr4。注意移动成功之后，ptr1 就变得没有意义了</span>
    cout <span class="token operator">&lt;&lt;</span> ptr4<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 3</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr5 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> ptr5<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Demo()&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Demo(int x)&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">Demo</span><span class="token punctuation">(</span>string str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Demo(string str)&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token operator">~</span><span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;~Demo()&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 std::make_shared 进行初始化，这是最常用的方式</span>
<span class="token keyword">void</span> <span class="token function">Test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// std::make_shared 的模板实参表示资源的类型，而参数是可变模板参数，表示需要匹配构造函数的参数</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span>Demo<span class="token operator">&gt;</span> ptr2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Demo<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span>Demo<span class="token operator">&gt;</span> ptr3 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Demo<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span>Demo<span class="token operator">&gt;</span> ptr4 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Demo<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">&quot;我是要成为海贼王的男人&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 通过 reset 的方法变相初始化，reset 本质上只是重置共享指针本身</span>
<span class="token keyword">void</span> <span class="token function">Test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr2 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr3 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr4 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ptr1 引用资源计数: &quot;</span> <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 4</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ptr2 引用资源计数: &quot;</span> <span class="token operator">&lt;&lt;</span> ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 4</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ptr3 引用资源计数: &quot;</span> <span class="token operator">&lt;&lt;</span> ptr3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 4</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ptr4 引用资源计数: &quot;</span> <span class="token operator">&lt;&lt;</span> ptr4<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 4</span>

    ptr4<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重置 ptr4 本身</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ptr1 引用资源计数: &quot;</span> <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 3</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ptr2 引用资源计数: &quot;</span> <span class="token operator">&lt;&lt;</span> ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 3</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ptr3 引用资源计数: &quot;</span> <span class="token operator">&lt;&lt;</span> ptr3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 3</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ptr4 引用资源计数: &quot;</span> <span class="token operator">&lt;&lt;</span> ptr4<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 0</span>

    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr5<span class="token punctuation">;</span>
    ptr5<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ptr5 引用资源计数: &quot;</span> <span class="token operator">&lt;&lt;</span> ptr5<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>获取原始指针<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 得到原始指针</span>
    <span class="token keyword">char</span><span class="token operator">*</span> original <span class="token operator">=</span> ptr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>original<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>original<span class="token punctuation">,</span> <span class="token string">&quot;我是要成为海贼王的男人&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;string value: &quot;</span> <span class="token operator">&lt;&lt;</span> original <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 注: char* 并不是字符串</span>

    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; == &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>获取 shared_ptr 形式的 &quot;this 指针&quot;<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Demo1</span> <span class="token punctuation">{</span>
    shared_ptr<span class="token operator">&lt;</span>Demo1<span class="token operator">&gt;</span> <span class="token function">GetSharedPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>Demo1<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 我想返回 shared_ptr 形式的 &quot;this 指针&quot;. 但很可惜当前这种写法后续会带来bug。这里新的shared_ptr&lt;Demo1&gt;(this)初始化使用的同一个原始指针this，所以还是原来那个问题，这个新的shared_ptr&lt;Demo1&gt;不知道与当前这个Demo1对象的shared_ptr&lt;Demo1&gt;共享资源</span>
    <span class="token punctuation">}</span>

    <span class="token operator">~</span><span class="token function">Demo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 基础知识：因为析构函数中没有显式的使用到实例成员，所以无论如何都能被正常调用</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;class Demo1 is disstruct ...&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Demo2</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">enable_shared_from_this</span><span class="token operator">&lt;</span><span class="token class-name">Demo2</span><span class="token operator">&gt;</span></span><span class="token punctuation">{</span>
    shared_ptr<span class="token operator">&lt;</span>Demo2<span class="token operator">&gt;</span> <span class="token function">GetSharedPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回 shared_ptr 形式的 &quot;this 指针&quot;. 内部使用的是 weak_ptr 指针的 lock 方法</span>
    <span class="token punctuation">}</span>

    <span class="token operator">~</span><span class="token function">Demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;class Demo2 is disstruct ... &quot;</span>  <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    shared_ptr<span class="token operator">&lt;</span>Demo1<span class="token operator">&gt;</span> <span class="token function">sp1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Demo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;use_count: &quot;</span> <span class="token operator">&lt;&lt;</span> sp1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 1</span>
    shared_ptr<span class="token operator">&lt;</span>Demo1<span class="token operator">&gt;</span> sp2 <span class="token operator">=</span> sp1<span class="token operator">-&gt;</span><span class="token function">GetSharedPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;use_count: &quot;</span> <span class="token operator">&lt;&lt;</span> sp2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 1 因为它不知道与其他共享指针共享资源，所以这里引用计数是 1</span>
    <span class="token comment">// sp2 先析构 =&gt; delete 原始指针，使得 sp1 内部的原始指针变成悬垂指针 =&gt; sp1 再析构 =&gt; delete 原始指针，抛异常</span>
    
    shared_ptr<span class="token operator">&lt;</span>Demo2<span class="token operator">&gt;</span> <span class="token function">sp3</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;use_count: &quot;</span> <span class="token operator">&lt;&lt;</span> sp3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 1</span>
    shared_ptr<span class="token operator">&lt;</span>Demo2<span class="token operator">&gt;</span> sp4 <span class="token operator">=</span> sp3<span class="token operator">-&gt;</span><span class="token function">GetSharedPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;use_count: &quot;</span> <span class="token operator">&lt;&lt;</span> sp4<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 2 </span>
    <span class="token comment">// sp3、sp3 分别正常析构，但原始指针只会被 delete 一次，对象资源同样也只会执行一次析构</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>智能指针有默认的删除器，但我们可以指定自定义的删除器<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">DeleteIntPtr</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 会将原始指针传入回调函数（删除器）中</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;int 的内存被删除了&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">,</span> DeleteIntPtr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 指定删除器</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;使用 lambda 表达式, int 的内存被删除了&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 删除数组资源</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr3</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 可以使用 c++11 提供的默认删除器（是个模板类），这个函数的内部也是通过 delete 来实现的</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr4</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">default_delete</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 注：这里是 ptr2 与 ptr1 分别析构，然后资源的引用计数分别为 0，再自动调用删除器进行删除</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="header-anchor">#</a> std::unique_ptr</h2> <ul><li>独占指针是三大智能指针之一，顾名思义就是对资源独占式的引用，所以它没有复制操作（构造或赋值），但有移动（构造或赋值）操作。</li> <li>它也是使用引用计数来实现对资源的自动管理，当资源被独占指针的引用计数为 0 时，资源将被 c++ 自动回收。
<ul><li>因为它是独占的，所以当 unique_ptr 被析构意味着它的资源就被析构了，所以在 c++ 中独占指针用的比 shared_ptr 指针更多</li></ul></li> <li>独占指针比较简单，直接上例子<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>

std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">GetUniquePtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 初始化</span>
<span class="token keyword">void</span> <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok 使用构造函数初始化，传入一个原始指针</span>
    <span class="token comment">// std::unique_ptr&lt;int&gt; ptr2 = ptr1; // error std::unique_ptr 没有复制操作（构造或赋值）</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr3 <span class="token operator">=</span> <span class="token function">GetUniquePtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok std::unique_ptr 有移动操作（构造或赋值）</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr4 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr5 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 同样也有 std::make_unique 函数来产生一个 unique_ptr since c++14</span>

    <span class="token comment">// std::cout &lt;&lt; ptr1.use_count() &lt;&lt; std::endl; // unique_ptr 并没有 use_count() 方法，并且它的引用计数永远是 1 或 0</span>
<span class="token punctuation">}</span>

<span class="token comment">// reset 与 release</span>
<span class="token keyword">void</span> <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ptr1 已经废了</span>
    ptr2<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重置 ptr2 意味着它的资源将被析构</span>
    ptr2<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重新管理新的内存, 原管理的内存的引用计数为0，将被 c++ 回收</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ptr2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; == &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ptr2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 获取原始指针的 api 还是一样的</span>

    <span class="token comment">// unqiue_ptr 的 release 方法，不释放资源，而是消亡自身并把资源给一个原生指针</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr3</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> rawPtr<span class="token punctuation">;</span>
    rawPtr <span class="token operator">=</span> ptr3<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;*rawPtr = &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>rawPtr <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 40</span>
<span class="token punctuation">}</span>

<span class="token comment">// swap</span>
<span class="token keyword">void</span> <span class="token function">Test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ptr1<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 交换两个智能指针的指向</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;after swap *ptr1 = &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ptr1 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 20</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;after swap *ptr2 = &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ptr2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 10</span>
<span class="token punctuation">}</span>

<span class="token comment">// 指定自定义的删除器</span>
<span class="token keyword">void</span> <span class="token function">Test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// std::unique_ptr 指定删除器和 std::shared_ptr 指定删除器是有区别的，std::unique_ptr 指定删除器必须通过模板实参指明删除器的类型</span>
    <span class="token keyword">using</span> FuncPointer <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> FuncPointer<span class="token operator">&gt;</span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果这里的 lambda 表达式捕获了变量，将发生编译错误</span>
        <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ptr1 的删除器被调用 ... &quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注：这里 lambda 表达式的类型与这个函数指针类型本质是不同的，只不过这个 lambda 表达式未捕获变量，可以隐式转换成这个函数指针类型</span>

    <span class="token comment">// 删除器的类型建议使用 std::function 类型来表示，比较全能一点</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span> <span class="token function">ptr2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">delete</span> p<span class="token punctuation">;</span>

        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ptr2 的删除器被调用 ... &quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 还可以使用 decltype</span>
    <span class="token keyword">auto</span> deleter <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ptr3 的删除器被调用 ... &quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>deleter<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">ptr3</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">,</span> deleter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>



<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="std-weak-ptr"><a href="#std-weak-ptr" class="header-anchor">#</a> std::weak_ptr</h2> <ul><li>弱指针是三大智能指针之一，但是它没有 shared_ptr 与 unique_ptr 一样具有实际的引用作用（不会影响引用计数），也没有重载指针的各种操作符。它的主要作用就是监视 shared_ptr 管理的资源</li> <li>初始化<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> wp1<span class="token punctuation">;</span> <span class="token comment">// 仅声明且实例化 weak_ptr 自身，但未提供其他的 shared_ptr 指针进行监控 </span>
   weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">wp2</span><span class="token punctuation">(</span>wp1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拷贝构造 当然对应的也有拷贝赋值函数，这里就不 bb 了</span>
   shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sp1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">wp3</span><span class="token punctuation">(</span>sp1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将它真正需要的共享指针传给它进行初始化</span>
   weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> wp4<span class="token punctuation">;</span>
   wp4 <span class="token operator">=</span> sp1<span class="token punctuation">;</span> <span class="token comment">// shared_ptr 可以隐式转换成 weak_ptr ，原因是 shared_ptr 重载了类型转换符</span>

   cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;wp1.use_count(): &quot;</span> <span class="token operator">&lt;&lt;</span> wp1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 0</span>
   cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;wp2.use_count(): &quot;</span> <span class="token operator">&lt;&lt;</span> wp2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 0</span>
   cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;wp3.use_count(): &quot;</span> <span class="token operator">&lt;&lt;</span> wp3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 1</span>
   cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;wp4.use_count(): &quot;</span> <span class="token operator">&lt;&lt;</span> wp4<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>expired 方法判断资源是否释放 注：当 weak_ptr 被 reset 了，同样也是 true<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sp1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">wp1</span><span class="token punctuation">(</span>sp1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;1. weak &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>wp1<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">&quot;is&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;is not&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; expired&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    sp1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;2. weak &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>wp1<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">&quot;is&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;is not&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; expired&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">wp2</span><span class="token punctuation">(</span>sp1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;3. weak &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>wp2<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">&quot;is&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;is not&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; expired&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    wp2<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;4. weak &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>wp2<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">&quot;is&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;is not&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; expired&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>lock 方法可以用来产生一个指向同一个资源的新的 shared_ptr<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">Test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> sp1<span class="token punctuation">,</span> sp2<span class="token punctuation">;</span>
  weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> wp<span class="token punctuation">;</span>

  sp1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  wp <span class="token operator">=</span> sp1<span class="token punctuation">;</span>
  sp2 <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sp2 是新的</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;use_count: &quot;</span> <span class="token operator">&lt;&lt;</span> wp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 2</span>

  sp1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;use_count: &quot;</span> <span class="token operator">&lt;&lt;</span> wp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// </span>

  sp1 <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sp1 又是新的</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;use_count: &quot;</span> <span class="token operator">&lt;&lt;</span> wp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 2</span>

  cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;*sp1 = &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 520</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;*sp2 = &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 520</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>weak_ptr 指针可以用来解决循环引用而造成的内存泄漏问题
<ul><li>使用 shared_ptr 造成的内存泄漏<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">B</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">&gt;</span> bptr<span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;class A is disstruct ...&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> aptr<span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;class B is disstruct ...&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">ap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">&gt;</span> <span class="token function">bp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;A obj use_count: &quot;</span> <span class="token operator">&lt;&lt;</span> ap<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 1</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B obj use_count: &quot;</span> <span class="token operator">&lt;&lt;</span> bp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 1</span>

    ap<span class="token operator">-&gt;</span>bptr <span class="token operator">=</span> bp<span class="token punctuation">;</span>
    bp<span class="token operator">-&gt;</span>aptr <span class="token operator">=</span> ap<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;A obj use_count: &quot;</span> <span class="token operator">&lt;&lt;</span> ap<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 2</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B obj use_count: &quot;</span> <span class="token operator">&lt;&lt;</span> bp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 2</span>
    <span class="token comment">// 离开作用域的时候，A 和 B 的内存实例的引用计数还是 1，即 A 和 B 的内存实例不会析构。原因是只有 ap 和 bp 析构了，但内存实例中的两个 shared_ptr 字段并没有被析构</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>将其中任意一个 shared_ptr 字段改成 weak_ptr 就可以解决问题<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">B</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    weak_ptr<span class="token operator">&lt;</span>B<span class="token operator">&gt;</span> bptr<span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;class A is disstruct ...&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> aptr<span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;class B is disstruct ...&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">ap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">&gt;</span> <span class="token function">bp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;A obj use_count: &quot;</span> <span class="token operator">&lt;&lt;</span> ap<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 1</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B obj use_count: &quot;</span> <span class="token operator">&lt;&lt;</span> bp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 1</span>

    ap<span class="token operator">-&gt;</span>bptr <span class="token operator">=</span> bp<span class="token punctuation">;</span>
    bp<span class="token operator">-&gt;</span>aptr <span class="token operator">=</span> ap<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;A obj use_count: &quot;</span> <span class="token operator">&lt;&lt;</span> ap<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 2</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B obj use_count: &quot;</span> <span class="token operator">&lt;&lt;</span> bp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 1</span>
    <span class="token comment">// 离开作用域的时候 bp 析构 =&gt; B 实例析构 =&gt; B 中的 shared_ptr&lt;A&gt; 析构。接着 ap 析构 =&gt; A实例析构</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li></ul> <h2 id="intializer-list"><a href="#intializer-list" class="header-anchor">#</a> intializer_list</h2> <ul><li>c++11 提供了一种类 intializer_list 专门接收 {} 值。并且使用 initializer_list 可以模仿其他语言中的可变参数。注意它只有一个模板类型参数。注：其实我们可以直接将 {} 看成隐式的 intializer_list<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;initializer_list&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">MyNumber</span> <span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> mv<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">MyNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;MyNumber(int, int, int) call...&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 使用显式的 initializer_list 参数可以模仿其他语言中的可变参数</span>
    <span class="token function">MyNumber</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> ele <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token operator">-&gt;</span>mv<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> ele <span class="token operator">:</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>mv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> ele <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> ele <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> ele <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    MyNumber nm1 <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 本质上用的就是 {1, 2, 3} 先隐式变成 intializer_list 再调用显式的 intializer_list 参数的构造函数. 如果不存在显式的 intializer_list 参数的构造函数，则会调用匹配的有参构造函数。注：如果 intializer_list 形参不符合实参的实际要求，那么也不会调用，比如说 intializer_list 形参是一个左值引用但实参没有左值语义</span>
    nm1<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    MyNumber <span class="token function">nm2</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 只会调用普通的有参构造函数</span>
    nm2<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {10, 20, 30, 40, 50, 60, 70, 80, 90, 100} 隐式变成 initializer_list&lt;int&gt;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> ele <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token number">10.0</span><span class="token punctuation">,</span> <span class="token number">20.1</span><span class="token punctuation">,</span> <span class="token number">30.5</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// {} 本质上就是 initializer_list</span>
  	  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> ele <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>intializer_list 中的元素类型必须完全相同，并且不支持隐式类型转换</li> <li>intializer_list 对象只能被整体初始化或赋值</li></ul> <h2 id="列表初始化-统一初始化"><a href="#列表初始化-统一初始化" class="header-anchor">#</a> 列表初始化(统一初始化)</h2> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Foo</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> n0<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n1<span class="token punctuation">{</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token keyword">double</span> <span class="token punctuation">{</span><span class="token number">1.2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    string s1<span class="token punctuation">{</span><span class="token char">'a'</span><span class="token punctuation">,</span><span class="token char">'b'</span> <span class="token punctuation">,</span><span class="token char">'c'</span> <span class="token punctuation">,</span><span class="token char">'d'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    string s2<span class="token punctuation">{</span> s1<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    string s3<span class="token punctuation">{</span> <span class="token number">0x61</span><span class="token punctuation">,</span><span class="token char">'a'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    string s4<span class="token punctuation">{</span> <span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token comment">// new 操作符也可以初始化</span>
    <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> pArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 类对象初始化</span>
    Foo a3 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    Foo a4<span class="token punctuation">{</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Hello World!\n&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="聚合体与非聚合体"><a href="#聚合体与非聚合体" class="header-anchor">#</a> 聚合体与非聚合体</h2> <ul><li>聚合体分类：
<ul><li>数组、以及满足条件的 class struct union: 无自定义构造函数、无基类、无虚函数、实例数据成员全部 public</li></ul></li> <li>不满足聚合体定义的当然就是非聚合体啦。聚合体和非聚合体的区别在于：聚合体使用 {} 初始化的时候是将每个值按顺序逐个赋值到字段进行初始化(本质上并没有使用构造函数)，并且可以使用 field : value 的语法指定初始化。而非聚合体使用 {} 初始化要求必须存在该 {} 对应参数的构造函数才行，并且不支持 field : value 语法</li> <li>存再非聚合体的字段，并不影响符合聚合体条件的 class struct union 是一个聚合体</li></ul> <h2 id="return"><a href="#return" class="header-anchor">#</a> return {}</h2> <p>没什么好说的，就是返回值可以用 {} 的方式构造返回值类型的对象返回</p> <h2 id="可变模板参数"><a href="#可变模板参数" class="header-anchor">#</a> 可变模板参数</h2> <ul><li>c++11 之前，模板参数的数量总是固定的。而可变模板参数的引入使得模板参数的数量可以不固定<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">&gt;</span> <span class="token comment">// ...Args 为可变模板参数包</span>
<span class="token keyword">void</span> <span class="token function">ShowList</span><span class="token punctuation">(</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// args 为可变函数形参包. 参数个数大于等于 0</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 使用 sizeof 获取形参包的个数，不过语法有点怪异就是了</span>

    <span class="token comment">// 错误示范</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 无法通过 [] 访问指定的形参</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">ShowList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ShowList</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>使用递归获取形参包中的参数-1<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// 无参的递归终止函数。推荐</span>
<span class="token keyword">void</span> <span class="token function">ShowListArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">FirstType</span><span class="token punctuation">,</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">ShowListArgs</span><span class="token punctuation">(</span>FirstType firstValue<span class="token punctuation">,</span> Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> firstValue <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 分离形参包中的第一个参数</span>
    <span class="token function">ShowListArgs</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 解包（解形参包），并递归</span>
<span class="token punctuation">}</span>

<span class="token comment">// 如果我们一开始就使用无参调用，那么直接调用就是递归终止函数。而我们本意是想无论如何都使用模板函数来调用，所以我们可以在外面套一层</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">ShowList</span><span class="token punctuation">(</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">ShowListArgs</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>使用递归获取形参包中的参数-2<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// 有参的递归终止函数。但是这个参数只能是模板参数，因为你并不知道最后一个形参的类型. 这种写法不推荐，因为这意味着你至少要使用一个形参来进行调用</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">LastType</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">ShowListArgs</span><span class="token punctuation">(</span><span class="token keyword">const</span> LastType<span class="token operator">&amp;</span> lastValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> lastValue <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">FirstType</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">ShowListArgs</span><span class="token punctuation">(</span>FirstType firstValue<span class="token punctuation">,</span> Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> firstValue <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 分离第一个形参</span>
    <span class="token function">ShowListArgs</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 解包，并递归</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">ShowList</span><span class="token punctuation">(</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">ShowListArgs</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>企图通过判断形参包中的数量为 0 来实现递归终止。错误示范<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">FirstType</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">ShowList</span><span class="token punctuation">(</span>FirstType firstValue<span class="token punctuation">,</span> Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> firstValue <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// 这里的 if 是一个运行时逻辑。编译期被忽略掉了</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">ShowListArgs</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模板是一个编译时逻辑，它会进行推演。当 args 里形参为 0 时，会继续推演，但 ShowListArgs 函数至少需要一个参数。所以报错</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">ShowList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>当参数包中的参数类型都是一样时，解包可以用于对数组进行初始化。但同时也意味着，参数包的数量必须大于 0，因为数组的长度是大于 0 的<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">ShowList</span><span class="token punctuation">(</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> ele <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> ele <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">ShowList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ShowList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ShowList(&quot;hello&quot;, &quot;world&quot;); // error</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>使用逗号表达式来获取参数包中的参数<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// 支持无参调用</span>
<span class="token keyword">void</span> <span class="token function">ShowList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;no arg call ...&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 每个形参的处理函数</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">ArgType</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">PrintArg</span><span class="token punctuation">(</span><span class="token keyword">const</span> ArgType<span class="token operator">&amp;</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;PrintArg: &quot;</span> <span class="token operator">&lt;&lt;</span> arg <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">ShowList</span><span class="token punctuation">(</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">PrintArg</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 逗号表达式第一表达式是函数调用，注意形参包不加 ... 第二个表达式是每次调用指定返回值。整个逗号表达式后面加 ... 表示将所有返回值解包</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> ele <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ShowList: &quot;</span> <span class="token operator">&lt;&lt;</span> ele <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">ShowList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ShowList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>使用逗号表达式的变体来获取参数包中的参数。最推荐<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// 提供无参调用</span>
<span class="token keyword">void</span> <span class="token function">ShowList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;no arg call ...&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 每个形参的处理函数</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">ArgType</span><span class="token operator">&gt;</span>
<span class="token keyword">int</span> <span class="token function">PrintArg</span><span class="token punctuation">(</span><span class="token keyword">const</span> ArgType<span class="token operator">&amp;</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;PrintArg: &quot;</span> <span class="token operator">&lt;&lt;</span> arg <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">ShowList</span><span class="token punctuation">(</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token function">PrintArg</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 不使用逗号表达式指定每次调用的返回值，而是由每次调用的函数返回值来确定。同样要使用 ... 来表达对所有返回值的解包</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> ele <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ShowList: &quot;</span> <span class="token operator">&lt;&lt;</span> ele <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">ShowList</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>c++11 提供 stl 容器的原始接口函数的 emplace 版本。底层也是用可变模板参数来实现的<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    list<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">&gt;&gt;</span> myList<span class="token punctuation">;</span>
    pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">&gt;</span> <span class="token function">kv</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">&quot;111&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 传统的</span>
    myList<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>kv<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传左值</span>
    myList<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">&quot;222&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传右值</span>
    myList<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token string">&quot;333&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传列表初始化</span>

    <span class="token comment">// emplace 的 since c++11</span>
    myList<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>kv<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传左值</span>
    myList<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token string">&quot;444&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传右值</span>
    myList<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token string">&quot;555&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不允许传列表初始化. 但可以依次传入用于构造元素的参数。注：当使用这种方式的时候，效率比传统的效率高一些</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="强类型枚举"><a href="#强类型枚举" class="header-anchor">#</a> 强类型枚举</h2> <ul><li>引入背景：c++11 之前的枚举是兼容 c 的，枚举值的作用域是父作用域，不需要使用枚举类名来限定，且可以隐式转换成整数。所以带来很多歧义</li> <li>c++11 引入强类型的枚举可以有效解决这两种问题。必须使用枚举类名来限定，且可以指定底层类型，转换必须是强转<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// 这里的 class 关键字可以用 struct 替代</span>
<span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">China</span> <span class="token punctuation">{</span>
    ShangHai<span class="token punctuation">,</span>
    Dongjing<span class="token punctuation">,</span>
    Beijing<span class="token punctuation">,</span>
    Nanjing
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 默认的底层类型是 int, 我们可以将它指定为 wchar_t 以外的任何整型</span>
<span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Japan</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">char</span></span> <span class="token punctuation">{</span>
    Dongjing<span class="token punctuation">,</span>
    Daban<span class="token punctuation">,</span>
    Hengbin<span class="token punctuation">,</span>
    Fudao
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// int m = Shanghai; // error</span>
    <span class="token comment">// int n = China::Beijing; // error</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">(</span>China<span class="token double-colon punctuation">::</span>Beijing<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ok!&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;size1: &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>China<span class="token double-colon punctuation">::</span>Beijing<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;size2: &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Japan<span class="token double-colon punctuation">::</span>Dongjing<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>对 c++11 之前的枚举拓展，同样可以使用强类型枚举的语法，但是并没有限制 c++11 之前的语法不能使用。所以建议不要用<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">enum</span> <span class="token class-name">Colors</span><span class="token operator">:</span> <span class="token keyword">char</span> <span class="token punctuation">{</span>
    Red<span class="token punctuation">,</span>
    Green<span class="token punctuation">,</span>
    Blue
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Colors c1 <span class="token operator">=</span> Green<span class="token punctuation">;</span> <span class="token comment">// 并没有限制 c++11 之前的语法</span>
    Colors c2 <span class="token operator">=</span> Colors<span class="token double-colon punctuation">::</span>Green<span class="token punctuation">;</span> <span class="token comment">// ok</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="拓展的-friend-语法"><a href="#拓展的-friend-语法" class="header-anchor">#</a> 拓展的 friend 语法</h2> <ul><li>c++11 开始支持对模板参数使用 friend<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Tom</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>  
<span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{</span>
    <span class="token keyword">friend</span> T<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Person<span class="token operator">&lt;</span>Tom<span class="token operator">&gt;</span> p<span class="token punctuation">;</span>
    Person<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> pp<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="原始字符串字面量"><a href="#原始字符串字面量" class="header-anchor">#</a> 原始字符串字面量</h2> <ul><li>原始字符串字面量就是不会进行转义的字符串字面量<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
  
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    string str1 <span class="token operator">=</span> <span class="token raw-string string">R&quot;(D:\hello\world\test.text)&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 按照字符串的字面意思，不会进行转义</span>
    cout <span class="token operator">&lt;&lt;</span> str1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    string str2 <span class="token operator">=</span> <span class="token raw-string string">R&quot;luffy(D:\hello\world\test.text)luffy&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 括号两边的字符串会被忽略</span>
    cout <span class="token operator">&lt;&lt;</span> str2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    string str3 <span class="token operator">=</span> R<span class="token string">&quot;luffy(D:\hello\world\test.text)robin&quot;</span><span class="token punctuation">;</span> <span class="token comment">// error 括号两边的字符串必须要一样</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="数值类型和和字符串之间的转换"><a href="#数值类型和和字符串之间的转换" class="header-anchor">#</a> 数值类型和和字符串之间的转换</h2> <ul><li>都是 <string> 头文件里面的一些 api . 参考文章: https://subingwen.cn/cpp/convert/</string></li></ul> <h2 id="begin和end函数"><a href="#begin和end函数" class="header-anchor">#</a> begin和end函数</h2> <ul><li>用来获取数组的首元素指针以及尾后指针<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> p1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">begin</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> p2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">end</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p1 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 1</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span>p2<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 10</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> p2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 10</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="chrono时间库"><a href="#chrono时间库" class="header-anchor">#</a> chrono时间库</h2> <ul><li>c++11之前并没有自己的时间库，而是依赖从c语言迁移过来的time时间库<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;ctime&gt;</span> <span class="token comment">// c语言time.h头文件的c++版本</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    time_t now <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回1970/01/01至今的秒数</span>
    cout <span class="token operator">&lt;&lt;</span> now <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;current time is &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token function">ctime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>now<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 将time_t转成字符串</span>

    tm<span class="token operator">*</span> timeInfo <span class="token operator">=</span> <span class="token function">localtime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;current Beijing(China) datetime is &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token function">asctime</span><span class="token punctuation">(</span>timeInfo<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 将tm转成字符串</span>

    tm<span class="token operator">*</span> timeInfo1 <span class="token operator">=</span> <span class="token function">gmtime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;current Reykjavik(Iceland) datetime is &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token function">asctime</span><span class="token punctuation">(</span>timeInfo1<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    tm timeInfo<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    timeInfo<span class="token punctuation">.</span>tm_year <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 距离1900年的100年</span>
    timeInfo<span class="token punctuation">.</span>tm_mon <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 一月</span>
    timeInfo<span class="token punctuation">.</span>tm_mday <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 该月的第一天</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;2000/01/01 represented by tm is &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token function">asctime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timeInfo<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    time_t t1 <span class="token operator">=</span> <span class="token function">mktime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timeInfo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 tm 转成 time_t 类型</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;2000/01/01 represented by time is &quot;</span> <span class="token operator">&lt;&lt;</span> t1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">strftime</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token string">&quot;Now it's %Y-%m-%d %H:%M:%S.&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>timeInfo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将tm格式化成字符串</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;format datetime is &quot;</span> <span class="token operator">&lt;&lt;</span> buff <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>c++11开始有自己的时间库chrono.
<ul><li>主要关注它提供的三种类：chrono::duration、时钟类、chrono::time_point 以及 std::ratio类
<ul><li>其中时钟类可分为: chrono::system_clock、chrono::steady_clock==chrono::high_resolution_clock</li> <li>chrono::time_point类模板又依赖于时钟类进行实例化。并且幸运的是，时钟类内部提供了chrono::time_point类模板的实例化类的别名类&quot;chrono::时钟类::time_point&quot;</li></ul></li> <li>std::ratio类<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// std::ratio结构体的原型</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span>intmax_t _Num<span class="token punctuation">,</span> intmax_t _Den <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">ratio</span><span class="token punctuation">;</span> <span class="token comment">// 这里的_Num是模板数值参数，表示分子; _Den也是模板数值参数，表示分母。它们的商表示多少秒。所以std::ratio是一个用来表示多少秒的类型</span>
</code></pre></div></li> <li>chrono::duration<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// std::chrono 命名空间下预定义的duration别名类</span>
    std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>hours <span class="token function">h</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1小时</span>
    std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>milliseconds ms<span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 3毫秒</span>
    std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>microseconds us<span class="token punctuation">{</span><span class="token number">2</span><span class="token operator">*</span>ms<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 6毫秒==6000微秒</span>
    
    <span class="token comment">// 自定义duration对象. 第一个类型参数是周期次数的类型，第二个类型参数是周期时长的类型</span>
    std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>ratio<span class="token operator">&lt;</span><span class="token number">1000</span><span class="token operator">&gt;&gt;</span> <span class="token function">ttSecond</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3000秒 注：std:ratio是一个表示可自定义秒的类模板</span>
    <span class="token comment">// std::chrono::duration&lt;int, std::ratio&lt;1000&gt;&gt; s1(3.5); // error 周期次数的类型是整数类型</span>
    std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">6.6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6.6 秒 因为第二个类型参数默认类型为1秒类型</span>
    std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>ratio<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token operator">&gt;&gt;</span> <span class="token function">hz1</span><span class="token punctuation">(</span><span class="token number">3.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 时间间隔为3.5*(1/30)秒</span>

    <span class="token comment">// 获取duration对象的周期次数</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;3ms duration has &quot;</span> <span class="token operator">&lt;&lt;</span> ms<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; ticks&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 3</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;6000us duration has &quot;</span> <span class="token operator">&lt;&lt;</span> us<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; ticks&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 6000</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;3.5hz duration has &quot;</span> <span class="token operator">&lt;&lt;</span> hz1<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 3.5</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// duration内部做了很多操作符重载，所以相同或不同的duration别名类之间可以直接进行算术运算，超级方便</span>
    std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>minutes <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>seconds <span class="token function">d2</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>seconds d3<span class="token punctuation">{</span>d1 <span class="token operator">-</span> d2<span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> d3<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 550</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
        注意：当两个duration的周期时长的类型不同进行加减运算的时候，会先进行一次周期时长的统一。
        比如ratio&lt;x1,y1&gt;与ratio&lt;x2,y2&gt;.首先计算x1与x2 的最大公因数X，然后计算y1与y2的最小公倍数Y. 最后得ratio&lt;X,Y&gt;
    */</span>
   std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>ratio<span class="token operator">&lt;</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token operator">&gt;&gt;</span> <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>ratio<span class="token operator">&lt;</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">&gt;&gt;</span> <span class="token function">d2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>ratio<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token operator">&gt;&gt;</span> d3<span class="token punctuation">{</span>d1 <span class="token operator">-</span> d2<span class="token punctuation">}</span><span class="token punctuation">;</span>
   <span class="token keyword">auto</span> d4<span class="token punctuation">{</span>d1 <span class="token operator">-</span> d2<span class="token punctuation">}</span><span class="token punctuation">;</span>
   std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> d3<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 31</span>
   std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> d4<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 31</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>时钟类与chrono::time_point<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> dday <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> ratio<span class="token operator">&lt;</span><span class="token number">3600</span><span class="token operator">*</span><span class="token number">24</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>

    <span class="token comment">// chrono::time_point&lt;时钟类, 时间间隔类&gt; 注：chrono::time_point类模板需要依赖于chrono::时钟类来实例化，幸运的是chrono::时钟类内部预定义了它的别名类型</span>
    chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span>time_point epoch<span class="token punctuation">;</span> <span class="token comment">// chrono::time_point默认初始化就是新纪元时间点1970/01/01. 注：这里的chrono::time_point类模板使用的是chrono::system_clock来实例化</span>
    chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span>time_point <span class="token function">t1</span><span class="token punctuation">(</span><span class="token function">dday</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 新纪元+20天的时间点. 传入一个duration对象是常见的一个构造方法</span>

    <span class="token comment">// 系统当前时间</span>
    chrono<span class="token double-colon punctuation">::</span>time_point<span class="token operator">&lt;</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token punctuation">,</span> chrono<span class="token double-colon punctuation">::</span>nanoseconds<span class="token operator">&gt;</span> today <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 建议将类型声明直接写成chrono::system_clock::time_point这个别名类</span>

    std<span class="token double-colon punctuation">::</span>time_t tm <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span><span class="token function">to_time_t</span><span class="token punctuation">(</span>today<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将chrono::system_clock::time_point 转成 std::time_t(c语言风格)</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;today is &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token function">ctime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tm<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 使用c语言风格的函数进行格式化字符串</span>
    tm <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span><span class="token function">to_time_t</span><span class="token punctuation">(</span>epoch<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;epoch is &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token function">ctime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tm<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    tm <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span><span class="token function">to_time_t</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;t1 is &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token function">ctime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tm<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果不是为了获取系统的时间，而是为了计时。那么可以使用steady_clock（固定时钟,可用来做计时器）</span>
    chrono<span class="token double-colon punctuation">::</span>steady_clock<span class="token double-colon punctuation">::</span>time_point start <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span>steady_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;test print 100 '*' ...&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;*&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    chrono<span class="token double-colon punctuation">::</span>steady_clock<span class="token double-colon punctuation">::</span>time_point end <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span>steady_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> duration <span class="token operator">=</span> end <span class="token operator">-</span> start<span class="token punctuation">;</span> <span class="token comment">// 注意获得的周期时长是纳秒</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;总共耗时: &quot;</span> <span class="token operator">&lt;&lt;</span> duration<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; 纳秒&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>chrono::duration_cast<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> print <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;print 100 '*'&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;*&quot;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> start <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span>high_resolution_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// high_resolution_clock是steady_clock的别名类型</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> end <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span>high_resolution_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> duration <span class="token operator">=</span> end <span class="token operator">-</span> start<span class="token punctuation">;</span>
    <span class="token comment">// 将纳秒为周期的duration转换成以毫秒为周期的duration. 注：只改变周期必须使用强制转换chrono::duration_cast</span>
    <span class="token keyword">auto</span> int_ms_duration <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">duration_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>chrono<span class="token double-colon punctuation">::</span>milliseconds<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>duration<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;总耗时: &quot;</span> <span class="token operator">&lt;&lt;</span> int_ms_duration<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; 毫秒&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token comment">// 将周期次数类型改变，如果原周期次数类型可以隐式转换成目标周期次数类型，那么转换可以是隐式的。</span>
    chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> ratio<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token operator">&gt;&gt;</span> double_ms_duration <span class="token operator">=</span> duration<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;总耗时: &quot;</span> <span class="token operator">&lt;&lt;</span> double_ms_duration<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; 毫秒&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>chrono::time_point_cast<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Duration</span><span class="token operator">&gt;</span>
<span class="token keyword">using</span> TimePoint <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span>time_point<span class="token operator">&lt;</span>chrono<span class="token double-colon punctuation">::</span>steady_clock<span class="token punctuation">,</span> Duration<span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// 注意到chrono::time_point能改变的只有它的时间间隔类型参数，所以我们只需要一个模板参数即可</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Duration</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">PrintDurationCountSinceEpoch</span><span class="token punctuation">(</span><span class="token keyword">const</span> TimePoint<span class="token operator">&lt;</span>Duration<span class="token operator">&gt;</span><span class="token operator">&amp;</span> timePoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> timePoint<span class="token punctuation">.</span><span class="token function">time_since_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    TimePoint<span class="token operator">&lt;</span>chrono<span class="token double-colon punctuation">::</span>seconds<span class="token operator">&gt;</span> <span class="token function">sec_time_point</span><span class="token punctuation">(</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 新纪元+10秒的时间点</span>
    <span class="token function">PrintDurationCountSinceEpoch</span><span class="token punctuation">(</span>sec_time_point<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6</span>
    TimePoint<span class="token operator">&lt;</span>chrono<span class="token double-colon punctuation">::</span>milliseconds<span class="token operator">&gt;</span> <span class="token function">ms_time_point</span><span class="token punctuation">(</span>sec_time_point<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 秒转毫秒不可能有精度损失，所以可以隐式类型转换</span>
    <span class="token function">PrintDurationCountSinceEpoch</span><span class="token punctuation">(</span>ms_time_point<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6000</span>

    ms_time_point <span class="token operator">=</span> <span class="token generic-function"><span class="token function">TimePoint</span><span class="token generic class-name"><span class="token operator">&lt;</span>chrono<span class="token double-colon punctuation">::</span>milliseconds<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">6331</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// TimePoint&lt;chrono::seconds&gt; t1(ms_time_point); // error 毫秒转秒可能有精度损失，不允许隐式类型转换</span>
    sec_time_point <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">time_point_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>chrono<span class="token double-colon punctuation">::</span>seconds<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>ms_time_point<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 允许强制转换chrono::time_point_cast，并且可能会丢失精度</span>
    <span class="token function">PrintDurationCountSinceEpoch</span><span class="token punctuation">(</span>sec_time_point<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li></ul></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/my-blog/cpp/列表初始化.html" class="prev">
          列表初始化
        </a></span> <span class="next"><a href="/my-blog/cpp/c++类型转换.html">
          c++类型转换
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#long-long-类型" class="sidebar-link reco-side-long-long-类型" data-v-b57cc07c>long long 类型</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#std-array" class="sidebar-link reco-side-std-array" data-v-b57cc07c>std::array</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#nullptr常量" class="sidebar-link reco-side-nullptr常量" data-v-b57cc07c>nullptr常量</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#constexpr" class="sidebar-link reco-side-constexpr" data-v-b57cc07c>constexpr</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#using-别名语法" class="sidebar-link reco-side-using-别名语法" data-v-b57cc07c>using 别名语法</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#auto-自动推导-编译期" class="sidebar-link reco-side-auto-自动推导-编译期" data-v-b57cc07c>auto 自动推导 (编译期)</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#decltype-类型推导-编译期" class="sidebar-link reco-side-decltype-类型推导-编译期" data-v-b57cc07c>decltype 类型推导 (编译期)</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#基于范围的-for-循环" class="sidebar-link reco-side-基于范围的-for-循环" data-v-b57cc07c>基于范围的 for 循环</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#lambda-表达式" class="sidebar-link reco-side-lambda-表达式" data-v-b57cc07c>lambda 表达式</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#std-function-与-std-bind" class="sidebar-link reco-side-std-function-与-std-bind" data-v-b57cc07c>std::function 与 std::bind</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#final-关键字" class="sidebar-link reco-side-final-关键字" data-v-b57cc07c>final 关键字</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#override-关键字" class="sidebar-link reco-side-override-关键字" data-v-b57cc07c>override 关键字</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#委托构造函数" class="sidebar-link reco-side-委托构造函数" data-v-b57cc07c>委托构造函数</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#继承构造函数" class="sidebar-link reco-side-继承构造函数" data-v-b57cc07c>继承构造函数</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#using-打开同名隐藏函数" class="sidebar-link reco-side-using-打开同名隐藏函数" data-v-b57cc07c>using 打开同名隐藏函数</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#static-assert" class="sidebar-link reco-side-static-assert" data-v-b57cc07c>static_assert</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#noexcept-关键字" class="sidebar-link reco-side-noexcept-关键字" data-v-b57cc07c>noexcept 关键字</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#右值引用" class="sidebar-link reco-side-右值引用" data-v-b57cc07c>右值引用</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#移动构造函数-右值引用的运用" class="sidebar-link reco-side-移动构造函数-右值引用的运用" data-v-b57cc07c>移动构造函数(右值引用的运用)</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#std-move-函数" class="sidebar-link reco-side-std-move-函数" data-v-b57cc07c>std::move 函数</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#std-forward-函数" class="sidebar-link reco-side-std-forward-函数" data-v-b57cc07c>std::forward 函数</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#特殊成员函数" class="sidebar-link reco-side-特殊成员函数" data-v-b57cc07c>特殊成员函数</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#default-与-delete" class="sidebar-link reco-side-default-与-delete" data-v-b57cc07c>= default 与 = delete</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#std-shared-ptr" class="sidebar-link reco-side-std-shared-ptr" data-v-b57cc07c>std::shared_ptr</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#std-unique-ptr" class="sidebar-link reco-side-std-unique-ptr" data-v-b57cc07c>std::unique_ptr</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#std-weak-ptr" class="sidebar-link reco-side-std-weak-ptr" data-v-b57cc07c>std::weak_ptr</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#intializer-list" class="sidebar-link reco-side-intializer-list" data-v-b57cc07c>intializer_list</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#列表初始化-统一初始化" class="sidebar-link reco-side-列表初始化-统一初始化" data-v-b57cc07c>列表初始化(统一初始化)</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#聚合体与非聚合体" class="sidebar-link reco-side-聚合体与非聚合体" data-v-b57cc07c>聚合体与非聚合体</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#return" class="sidebar-link reco-side-return" data-v-b57cc07c>return {}</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#可变模板参数" class="sidebar-link reco-side-可变模板参数" data-v-b57cc07c>可变模板参数</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#强类型枚举" class="sidebar-link reco-side-强类型枚举" data-v-b57cc07c>强类型枚举</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#拓展的-friend-语法" class="sidebar-link reco-side-拓展的-friend-语法" data-v-b57cc07c>拓展的 friend 语法</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#原始字符串字面量" class="sidebar-link reco-side-原始字符串字面量" data-v-b57cc07c>原始字符串字面量</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#数值类型和和字符串之间的转换" class="sidebar-link reco-side-数值类型和和字符串之间的转换" data-v-b57cc07c>数值类型和和字符串之间的转换</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#begin和end函数" class="sidebar-link reco-side-begin和end函数" data-v-b57cc07c>begin和end函数</a></li><li class="level-2" data-v-b57cc07c><a href="/my-blog/cpp/c++11.html#chrono时间库" class="sidebar-link reco-side-chrono时间库" data-v-b57cc07c>chrono时间库</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/my-blog/assets/js/app.8e128a0c.js" defer></script><script src="/my-blog/assets/js/7.9bc745bc.js" defer></script><script src="/my-blog/assets/js/2.1c59524a.js" defer></script><script src="/my-blog/assets/js/1.4270a9d7.js" defer></script><script src="/my-blog/assets/js/39.73ed935c.js" defer></script>
  </body>
</html>
